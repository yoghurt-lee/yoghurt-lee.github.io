<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fate</title>
  <subtitle>但行好事,莫问前程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoghurt-lee.github.io/"/>
  <updated>2017-05-28T01:22:46.568Z</updated>
  <id>https://yoghurt-lee.github.io/</id>
  
  <author>
    <name>yoghurt-lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pygame实现贪吃蛇和2048</title>
    <link href="https://yoghurt-lee.github.io/2017/05/28/pygame%E5%AE%9E%E7%8E%B0%E8%B4%AA%E5%90%83%E8%9B%87%E5%92%8C2048/"/>
    <id>https://yoghurt-lee.github.io/2017/05/28/pygame实现贪吃蛇和2048/</id>
    <published>2017-05-28T00:20:09.000Z</published>
    <updated>2017-05-28T01:22:46.568Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i4.buimg.com/584643/09ee09475c2f987a.png" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>很久没有更新博客啦,今天端午节放假，正好有时间更新下博客,把前两个星期完成的软工作业写成一篇博客好了(大雾).</p>
</blockquote>
<h3 id="pygame"><a href="#pygame" class="headerlink" title="pygame"></a>pygame</h3><ul>
<li><p>pygame 网上有一篇非常完整<a href="http://eyehere.net/2011/python-pygame-novice-professional-1/" target="_blank" rel="external">教程</a>,大家有兴趣的可以去学习一个，做一点2D游戏也是很有趣的.</p>
</li>
<li><p>为了完成软工作业，我和同学一人做了两个<code>pygame</code>的小游戏,他做了<code>Flappy Brids</code>和<code>俄罗斯方块</code>,我做了<code>2048</code>和<code>贪吃蛇</code>.所以在这里我只介绍我自己写的两个游戏.另外两个游戏，可以去这个<a href="http://flandre.site/" target="_blank" rel="external">博客</a>,不知道会不会更新..</p>
</li>
<li><p><a href="https://github.com/yoghurt-lee/pygame" target="_blank" rel="external">github地址</a>,大家如果觉得好的话，希望能够点个<code>star</code>呀.</p>
</li>
</ul>
<h3 id="贪吃蛇"><a href="#贪吃蛇" class="headerlink" title="贪吃蛇"></a>贪吃蛇</h3><ul>
<li><p>这是一款非常老的游戏了，我选这个的原因是因为刚刚接触<code>pygame</code>,所以做一个容易一点的游戏,后来做完2048之后想做一个连连看的，懒癌发作就没写了.</p>
</li>
<li><p>游戏界面<br><img src="http://i4.buimg.com/584643/612ae44cc47edb4b.png" alt="Markdown"></p>
</li>
<li><p>游戏的主循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">def runGame():</div><div class="line">   #游戏主循环</div><div class="line">   startx = random.randint(5, CELLWIDTH - 6)</div><div class="line">   starty = random.randint(5,CELLHEIGHT - 6)</div><div class="line">   #最开始蛇长度为 3</div><div class="line">   snake = [</div><div class="line">       &#123;&apos;x&apos;:startx,&apos;y&apos;: starty&#125;,</div><div class="line">       &#123;&apos;x&apos;: startx - 1, &apos;y&apos;: starty&#125;,</div><div class="line">       &#123;&apos;x&apos;: startx - 2, &apos;y&apos;: starty&#125;</div><div class="line">   ]</div><div class="line">   #最开始的方向</div><div class="line">   direction = RIGHT</div><div class="line">   #生成苹果位置</div><div class="line">   apple = appleLocation()</div><div class="line">   #循环一次的时间</div><div class="line">   TIME = 0.1</div><div class="line">   #蛇的长度作为一个标志,如果这个标志变化了,那么TIME也就变化，控制游戏难度</div><div class="line">   laststate = len(snake)</div><div class="line">   while True:</div><div class="line">       SCREEN.blit(BACKGROUND_PICTURE,(0,0))</div><div class="line">       #draw_grid()</div><div class="line">       #蛇死亡后返回</div><div class="line">       if snakeDie(snake):</div><div class="line">           return</div><div class="line">       lastdirection = direction #记录前一个方向,防止出现BUG</div><div class="line">       #事件循环</div><div class="line">       for event in pygame.event.get():</div><div class="line">           if event.type==QUIT:</div><div class="line">               exit()</div><div class="line">           elif event.type == KEYDOWN:</div><div class="line">               key = event.key</div><div class="line">               if lastdirection != RIGHT:</div><div class="line">                   if (key ==K_a or key==K_LEFT) and direction!=RIGHT: #往左</div><div class="line">                       direction = LEFT</div><div class="line">               if lastdirection != LEFT:</div><div class="line">                   if (key ==K_d or key==K_RIGHT) and direction!=LEFT: #往右</div><div class="line">                       direction = RIGHT</div><div class="line">               if lastdirection != DOWN:</div><div class="line">                   if (key ==K_a or key==K_UP) and direction!=DOWN: #往上</div><div class="line">                       direction = UP</div><div class="line">               if lastdirection != UP:</div><div class="line">                   if (key ==K_s or key==K_DOWN) and direction!=UP: #往下</div><div class="line">                       direction = DOWN</div><div class="line">               if key==K_ESCAPE:</div><div class="line">                   exit()</div><div class="line">       #吃到了苹果，生成新苹果,否则，删除蛇的尾巴</div><div class="line">       if snake[HEAD][&apos;x&apos;]== apple[&apos;x&apos;] and snake[HEAD][&apos;y&apos;] == apple[&apos;y&apos;]:</div><div class="line">           apple = appleLocation()</div><div class="line">       else:</div><div class="line">           del snake[-1] #删除掉蛇的尾巴</div><div class="line">       #新的头</div><div class="line">       new_head = &#123;&apos;x&apos;:snake[HEAD][&apos;x&apos;]+direction[0],&apos;y&apos;:snake[HEAD][&apos;y&apos;]+direction[1]&#125;</div><div class="line">       snake.insert(0,new_head)</div><div class="line">       #绘制蛇,苹果，分数</div><div class="line">       draw_snake(snake)</div><div class="line">       draw_apple(apple)</div><div class="line">       draw_score(10*(len(snake)-3))</div><div class="line">       #绘制鼠标</div><div class="line">       (x,y) = pygame.mouse.get_pos()</div><div class="line">       SCREEN.blit(MOUSEIMAGE,(x-MOUSEIMAGE.get_width()/2,y-MOUSEIMAGE.get_height()/2))</div><div class="line">       #刷新屏幕</div><div class="line">       pygame.display.update()</div><div class="line">       FPSCLOCK.tick(FPS)</div><div class="line">       #蛇的当前长度为蛇的当前状态</div><div class="line">       nowstate = len(snake)</div><div class="line">       #状态变化</div><div class="line">       if laststate!=nowstate:</div><div class="line">           TIME-=0.005</div><div class="line">           laststate = nowstate</div><div class="line">       #确保循环时间合理性</div><div class="line">       if TIME&lt;0: TIME = 0</div><div class="line">       time.sleep(TIME)</div></pre></td></tr></table></figure>
</li>
<li><p>注释都已经写得清楚了，解释一下为啥要设置一个<code>lastdirection</code>:在玩的过程中，发现在快速按键的情况下蛇会莫名死亡，后来发现是由于前一步的设置了游戏难度，每次都等待了0.1s,当在这0.1s的等待时间内，如果触发了多个事件，就有可能出BUG，比如我这次的方向是向RIGHT，在等待的0.1s内进来了两个时间UP,LEFT，等到下一次进入事件循环时，我们的当前状态就会从RIGHT变成UP，然后又变成了LEFT，于是蛇的方向就相反了；解决方案是设置一个<code>lastdirection</code>状态，每次都需判断这次的方向不能与<code>lastdirection</code>方向相反.</p>
</li>
</ul>
<h3 id="2048"><a href="#2048" class="headerlink" title="2048"></a>2048</h3><ul>
<li><p>这个游戏其实我大二的时候就用<code>JAVA</code>实现过了，现在又用<code>pygame</code>写一遍,逻辑是差不多.高三的时候一直觉得这个游戏很好玩的.</p>
</li>
<li><p>主页面</p>
</li>
</ul>
<p><img src="http://i4.buimg.com/584643/e9933cee1faca4f0.png" alt="Markdown"></p>
<ul>
<li><p>这个游戏主要是弄清方块怎么移动的，就很容易实现了.每次移动的过程中，运算时通过三重循环迭代进行实现的,比如UP的操作,引发的事件就是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">For y: 1-&gt;3</div><div class="line">	For x: 0-&gt;3</div><div class="line">		For y1: y-&gt;0</div></pre></td></tr></table></figure>
</li>
<li><p>每一行都受其下面所有行的影响,而这一行又会影响其上面的每一行,所以通过三重循环模拟递推过程，可以实现移动操作。</p>
</li>
<li><p>移动的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">def moveKey(e):</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    判定键盘事件</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    global SCORE,TIMES #引用全局变量,如果要修改全局变量的值必须这么弄,不然SCORE会被认为是局部变量</div><div class="line">    flag = False #标志整个图是否发生了变化,如果发生了变化就调用 create()</div><div class="line">    # 触发了向上的操作</div><div class="line">    if e.key == K_UP or e.key == K_w:</div><div class="line">        for y in range(1,SIZE):</div><div class="line">            for x in range(0,SIZE):</div><div class="line">                if array[x][y] == 0: continue</div><div class="line">                dispos = -1 # 标记位置 ,如果这个dispos一直为-1 ,那么证明y以上的所有位置都不会被y代替的位置,否则y1的位置将被y位置的元素代替</div><div class="line">                for y1 in range(y-1,-1,-1):</div><div class="line">                    if array[x][y1]!=0:</div><div class="line">                        if array[x][y] == array[x][y1]:</div><div class="line">                            flag = True</div><div class="line">                            dispos = -1</div><div class="line">                            SCORE += 2*array[x][y1]</div><div class="line">                            array[x][y1]*=2</div><div class="line">                            array[x][y] = 0</div><div class="line">                            TIMES+=1 #空位增加了</div><div class="line">                        break #直接退出循环,该层已经不可能再往上走了</div><div class="line">                    else:</div><div class="line">                        dispos = y1</div><div class="line">                #不为-1的情况</div><div class="line">                if dispos is not -1:</div><div class="line">                    flag = True</div><div class="line">                    array[x][dispos] = array[x][y]</div><div class="line">                    array[x][y] = 0</div><div class="line">    #触发了向下的操作</div><div class="line">    if e.key == K_DOWN or e.key == K_s:</div><div class="line">        for y in range(SIZE-1,-1,-1):</div><div class="line">            for x in range(0,4):</div><div class="line">                if array[x][y] == 0: continue</div><div class="line">                dispos = -1</div><div class="line">                for y1 in range(y+1,SIZE):</div><div class="line">                    if array[x][y1]!=0:</div><div class="line">                        if array[x][y] == array[x][y1]:</div><div class="line">                            flag = True</div><div class="line">                            dispos = -1</div><div class="line">                            SCORE += 2*array[x][y1]</div><div class="line">                            array[x][y1]*=2</div><div class="line">                            array[x][y] = 0</div><div class="line">                            TIMES+=1 #空位增加了</div><div class="line">                        break #直接退出循环,该层已经不可能再往上走了</div><div class="line">                    else:</div><div class="line">                        dispos = y1</div><div class="line">                if dispos is not -1:</div><div class="line">                    flag = True</div><div class="line">                    array[x][dispos] = array[x][y]</div><div class="line">                    array[x][y] = 0</div><div class="line">    #触发了向左的操作</div><div class="line">    if e.key == K_a or e.key == K_LEFT:</div><div class="line">        for y in range(0,SIZE):</div><div class="line">            for x in range(1,SIZE):</div><div class="line">                if array[x][y] == 0:continue</div><div class="line">                dispos = -1</div><div class="line">                for x1 in range(x-1,-1,-1):</div><div class="line">                    if array[x1][y] !=0:</div><div class="line">                        if array[x1][y]== array[x][y]:</div><div class="line">                            flag = True</div><div class="line">                            dispos = -1</div><div class="line">                            SCORE += 2*array[x1][y]</div><div class="line">                            array[x1][y]*=2</div><div class="line">                            array[x][y] = 0</div><div class="line">                            TIMES+=1</div><div class="line">                        break</div><div class="line">                    else:</div><div class="line">                        dispos = x1</div><div class="line">                if dispos is not -1:</div><div class="line">                    flag = True</div><div class="line">                    array[dispos][y] = array[x][y]</div><div class="line">                    array[x][y] = 0</div><div class="line">    #触发了向右的操作</div><div class="line">    if e.key == K_d or e.key == K_RIGHT:</div><div class="line">        for y in range(0,SIZE):</div><div class="line">            for x in range(SIZE-1,-1,-1):</div><div class="line">                if array[x][y] == 0:continue</div><div class="line">                dispos = -1</div><div class="line">                for x1 in range(x+1,SIZE):</div><div class="line">                    if array[x1][y] !=0:</div><div class="line">                        if array[x1][y]== array[x][y]:</div><div class="line">                            flag = True</div><div class="line">                            dispos = -1</div><div class="line">                            SCORE += 2*array[x1][y]</div><div class="line">                            array[x1][y]*=2</div><div class="line">                            array[x][y] = 0</div><div class="line">                            TIMES+=1</div><div class="line">                        break</div><div class="line">                    else:</div><div class="line">                        dispos = x1</div><div class="line">                if dispos is not -1:</div><div class="line">                    flag = True</div><div class="line">                    array[dispos][y] = array[x][y]</div><div class="line">                    array[x][y] = 0</div><div class="line">    if flag:</div><div class="line">        #创造新数字方块</div><div class="line">        create()</div></pre></td></tr></table></figure>
</li>
<li><p>每次调用<code>create</code>函数生成4(0.25的概率)或者2(0.75的概率)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def create():</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    在空方块处产生新的数字</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    flag = False # 直到某个空位置产生一个新的数 flag 才变成 0</div><div class="line">    if TIMES&gt;0:</div><div class="line">        while not flag:</div><div class="line">            x = random.randint(0,3)</div><div class="line">            y = random.randint(0,3)</div><div class="line">            #print x,y</div><div class="line">            if array[x][y] == 0:</div><div class="line">                if random.randint(0,3) == 0: #1/4的几率生成 4</div><div class="line">                    array[x][y] = 4</div><div class="line">                else:</div><div class="line">                    array[x][y] = 2</div><div class="line">                flag = True</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul>
<li>估计更新完这一篇又要拖更了,珍惜每一次假期和学习的机会呀,大学多学点东西,工作起来可能更加没时间学东西了</li>
<li><a href="https://github.com/yoghurt-lee/pygame" target="_blank" rel="external">本游戏的<code>github</code>地址</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i4.buimg.com/584643/09ee09475c2f987a.png&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://yoghurt-lee.github.io/tags/python/"/>
    
      <category term="pygame" scheme="https://yoghurt-lee.github.io/tags/pygame/"/>
    
      <category term="小游戏" scheme="https://yoghurt-lee.github.io/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据分析:知乎专栏哔哩哔哩篇</title>
    <link href="https://yoghurt-lee.github.io/2017/04/25/zhihu-bilibili-topic/"/>
    <id>https://yoghurt-lee.github.io/2017/04/25/zhihu-bilibili-topic/</id>
    <published>2017-04-25T14:37:11.000Z</published>
    <updated>2017-04-26T14:42:29.701Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i2.muimg.com/584643/ee5427f32c65bc73.jpg" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>我用爬虫挂了一天半,从知乎的哔哩哔哩专栏中得到了200+个精华问题的所有回答,我们能够在这里得到什么呢?</p>
</blockquote>
<h3 id="word2vec简介"><a href="#word2vec简介" class="headerlink" title="word2vec简介"></a>word2vec简介</h3><blockquote>
<p>Word2vec 是 Google 在 2013 年年中开源的一款将词表征为实数值向量的高效工具, 其利用深度学习的思想，可以通过训练，把对文本内容的处理简化为 K 维向量空间中的向量运算，而向量空间上的相似度可以用来表示文本语义上的相似度。Word2vec输出的词向量可以被用来做很多 NLP 相关的工作，比如聚类、找同义词、词性分析等等。如果换个思路， 把词当做特征，那么Word2vec就可以把特征映射到 K 维向量空间，可以为文本数据寻求更加深层次的特征表示 。</p>
</blockquote>
<p>这里的算法原理已经和机器学习挂钩了,我们不做深度剖析(<a href="http://wei-li.cnblogs.com/p/word2vec.html" target="_blank" rel="external">算法的简介</a>),只要使用其python包.然后介绍一下这里需要使用的方法.</p>
<ul>
<li><p>在使用<code>word2vec</code>之前请先装好<code>codecs</code>模块,这个模块可以免去读取文件时很多编码的麻烦,专门针对自然语言处理的编码转换,只要指定一个编码方式打开文件就ok了.</p>
</li>
<li><p><code>word2vec</code>的导入以及使用:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from gensim.models import word2vec #导入模块</div><div class="line">sentences = word2vec.LineSentence(filename) #从文件中读入语料</div><div class="line"></div><div class="line">#sentences 指的是训练语料,</div><div class="line">#window指词向量训练时上下文扫描窗口大小,为5就考虑前5个词和后5个词</div><div class="line">#size指的是每个词的向量维度,</div><div class="line">#min_count指的是最低频率,默认为5,如果一个词出现次数小于5,那么就丢弃</div><div class="line">#workers指训练的进程数,默认是当前运行机器的处理器核数.</div><div class="line">model = word2vec.Word2Vec(sentences, size=200,window=5,min_count=10,workers=3)</div></pre></td></tr></table></figure>
<ul>
<li><code>word2vec</code>里面的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">print model[u&apos;XXX&apos;] #获取词向量,类型为`numpy.ndarray`,维数为上面指定的size</div><div class="line"></div><div class="line">#计算与一个词的最近似topn个词，按照余弦相似度从大到小排列</div><div class="line">result = model.most_similar(u&apos;XXX&apos;,topn=10)</div><div class="line">for each in result:</div><div class="line">    print each[0] , each[1]</div><div class="line">#支持词语的加减运算(很神奇啊!) 比如&apos;希拉里&apos;对应&apos;加州&apos;,&apos;川普&apos;对应&apos;德州&apos;,那么&apos;希拉里&apos;+&apos;加州&apos;-&apos;川普&apos;=&apos;德州&apos;</div><div class="line">model.most_similar(positive=[u&quot;希拉里&quot;,u&quot;加州&quot;],negative=[u&quot;德州&quot;], topn=1)</div><div class="line">#两词之间的余弦相似度</div><div class="line">print model.similarity(u&apos;XXX&apos;, u&apos;YYY&apos;)</div><div class="line"></div><div class="line">#计算两个集合之间的余弦似度</div><div class="line">list1 = [u&apos;今天&apos;, u&apos;我&apos;, u&apos;很&apos;, u&apos;开心&apos;]</div><div class="line">list2 = [u&apos;空气&apos;,u&apos;清新&apos;, u&apos;善良&apos;, u&apos;开心&apos;]</div><div class="line">list_sim1 =  model.n_similarity(list1, list2)</div><div class="line"></div><div class="line">#选出集合中不同类的词语</div><div class="line">list = [u&apos;纽约&apos;, u&apos;北京&apos;, u&apos;上海&apos;, u&apos;西安&apos;]</div><div class="line">print model.doesnt_match(list) #自然是西瓜咯</div></pre></td></tr></table></figure>
<h3 id="jieba分词"><a href="#jieba分词" class="headerlink" title="jieba分词"></a>jieba分词</h3><ul>
<li><p>先利用jieba将爬下来的文本进行分词,将自定义的词典和自定义的<code>stopwords</code>加进来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#部分自定义词典</div><div class="line">bilibibi</div><div class="line">noconico</div><div class="line">acfun</div><div class="line">爱奇艺</div><div class="line">土豆</div><div class="line">优酷</div><div class="line">哔哩哔哩</div><div class="line">ACG</div><div class="line">b站</div><div class="line">B站</div><div class="line">节奏大师</div><div class="line">A站</div><div class="line">炮姐</div><div class="line">御坂美琴</div><div class="line">2233娘</div><div class="line">bishi</div><div class="line">9bishi</div><div class="line">小学生</div><div class="line">徐逸</div><div class="line">陈睿</div><div class="line">鬼畜</div><div class="line">二次元</div><div class="line">...</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#部分stopwords</div><div class="line">其实</div><div class="line">已经</div><div class="line">大家</div><div class="line">很多</div><div class="line">觉得</div><div class="line">喜欢</div><div class="line">现在</div><div class="line">真的</div><div class="line">看到</div><div class="line">这种</div><div class="line">可能</div><div class="line">感觉</div><div class="line">一下</div><div class="line">不能</div><div class="line">来说</div><div class="line">非常</div><div class="line">一点</div><div class="line">之后</div><div class="line">之前</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
</ul>
<p>分完词后大约还有20M的文本<br><img src="http://i1.piimg.com/584643/e00d0eb68c22db58.png" alt="Markdown"><br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#coding:utf-8</div><div class="line">import jieba</div><div class="line">import codecs</div><div class="line">import re,os</div><div class="line">jieba.load_userdict(u&apos;data_analysis/mydict.txt&apos;) # 自定义词典的路径</div><div class="line">with codecs.open(u&apos;data_analysis/text.txt&apos;,&apos;r&apos;,&apos;utf-8&apos;) as f:</div><div class="line">    sentences = f.readlines()</div><div class="line">stopwordfile=codecs.open(&quot;data_analysis/stopwords.txt&quot;,&quot;r&quot;,&apos;utf-8&apos;)</div><div class="line">stopwords=stopwordfile.readlines()</div><div class="line">stopwords=[re.sub(&quot;\r\n|\n&quot;,&quot;&quot;,word) for word in stopwords]</div><div class="line">stopwords.append(&apos;\n&apos;)</div><div class="line">if os.path.exists(u&apos;data_analysis/cut_text.txt&apos;):</div><div class="line">    os.remove(u&apos;data_analysis/cut_text.txt&apos;)</div><div class="line">for sentence in sentences:</div><div class="line">    text =  &apos; &apos;.join([word for word in jieba.cut(sentence) if len(word)&gt;1 and word not in stopwords])</div><div class="line">    with codecs.open(u&apos;data_analysis/cut_text.txt&apos;,&apos;a&apos;) as f:</div><div class="line">        f.write(text)</div></pre></td></tr></table></figure></p>
<h3 id="统计词频"><a href="#统计词频" class="headerlink" title="统计词频"></a>统计词频</h3><ul>
<li><p>我们先对文本中出现最多的进行一次统计,看看回答中出现的的最多的是哪些?我们这里总共有<code>5943182</code>个词.<br><img src="http://i1.piimg.com/584643/1c1a0450a770b291.png" alt="Markdown"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">下标 名称 出现次数</div><div class="line">97414 视频 23371</div><div class="line">54703 弹幕 23150</div><div class="line">4519 B站 22880</div><div class="line">11108 b站 18979</div><div class="line">107100 问题 11080</div><div class="line">53473 广告 9541</div><div class="line">22541 二次元 8516</div><div class="line">81406 用户 8511</div><div class="line">33925 动画 8490</div><div class="line">20256 中国 8114</div><div class="line">90403 网站 7714</div><div class="line">76830 游戏 7170</div><div class="line">33915 动漫 6748</div><div class="line">25484 会员 6385</div><div class="line">81685 电影 5912</div><div class="line">83461 直播 5855</div><div class="line">19501 东西 5832</div><div class="line">98289 评论 5623</div><div class="line">31548 出来 5205</div><div class="line">26480 作品 5018</div><div class="line">111438 鬼畜 4883</div><div class="line">66494 日本 4673</div><div class="line">32541 别人 4347</div><div class="line">84898 知乎 4334</div><div class="line">41814 回答 4155</div><div class="line">19316 世界 4144</div><div class="line">10933 bilibili 4089</div><div class="line">88315 粉丝 3905</div><div class="line">65153 文化 3866</div><div class="line">52613 希望 3822</div></pre></td></tr></table></figure>
</li>
<li><p>可以看到视频,弹幕,B站出现的次数稳居前三,同时我们自定义词典中二次元,鬼畜这些词也都在.这些数据还是比较符合我们的预期的,同时也证明了分出来的词没问题.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#coding: utf-8</div><div class="line">import re</div><div class="line">import time</div><div class="line">import numpy as np</div><div class="line">import pandas</div><div class="line">import jieba</div><div class="line">import os</div><div class="line">from wordcloud import WordCloud</div><div class="line">import matplotlib.pyplot as plt</div><div class="line">from pylab import *</div><div class="line">import codecs</div><div class="line">mpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;]</div><div class="line">mpl.rcParams[&apos;axes.unicode_minus&apos;] = False</div><div class="line"></div><div class="line">#遍历文件中的数据</div><div class="line">with codecs.open(u&quot;data_analysis/cut_text.txt&quot;,&apos;r&apos;,&apos;utf-8&apos;) as f:</div><div class="line">    context=f.read()</div><div class="line">segment = context.split()</div><div class="line"></div><div class="line">#去停用词</div><div class="line">words_df=pandas.DataFrame(&#123;&apos;segment&apos;:segment&#125;)</div><div class="line">words_df.head()</div><div class="line">stopwords = []</div><div class="line">with codecs.open(&apos;data_analysis/stopwords.txt&apos;,&apos;r&apos;,&apos;utf-8&apos;) as f:</div><div class="line">    context = f.read()</div><div class="line">stopwords = context.split()</div><div class="line">words_df=words_df[~words_df.segment.isin(stopwords)]</div><div class="line"></div><div class="line">#统计词频</div><div class="line">words_stat=words_df.groupby(by=[&apos;segment&apos;])[&apos;segment&apos;].agg(&#123;&quot;number&quot;:np.size&#125;)</div><div class="line">words_stat=words_stat.reset_index().sort_values(by=&quot;number&quot;,ascending=False)</div><div class="line">print &apos;index&apos;,&apos;segment&apos;,&apos;number&apos;</div><div class="line">for index,Series in words_stat.head(30).iterrows():</div><div class="line">    print index,Series[&apos;segment&apos;].decode(&apos;utf-8&apos;),Series[&apos;number&apos;]</div><div class="line"></div><div class="line">words_stat[:30].plot(x=&apos;segment&apos;, y=&apos;number&apos;, kind=&apos;bar&apos;)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="利用word2vec进行数据挖掘"><a href="#利用word2vec进行数据挖掘" class="headerlink" title="利用word2vec进行数据挖掘"></a>利用word2vec进行数据挖掘</h3><ul>
<li><p>我们将对b站站长<code>bishi</code>在window这个参数上，分别设置上下文跨度为5,10和15。找到与<code>bishi</code>最接近的20个关键词.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">model1 = word2vec.Word2Vec(sentences, size=200,window=5,min_count=10,workers=3)</div><div class="line">model2 = word2vec.Word2Vec(sentences, size=200,window=10,min_count=10)</div><div class="line">model3 = word2vec.Word2Vec(sentences, size=200,window=15,min_count=10)</div><div class="line">y_t_1 = model1.most_similar(u&apos;bishi&apos;,topn=20)</div><div class="line">y_t_2 = model2.most_similar(u&apos;bishi&apos;,topn=20)</div><div class="line">y_t_3 = model3.most_similar(u&apos;bishi&apos;,topn=20)</div><div class="line">#输出结果</div><div class="line">for item in y_t_1:</div><div class="line">    print item[0],item[1]</div><div class="line">print</div><div class="line">for item in y_t_2:</div><div class="line">    print item[0],item[1]</div><div class="line">print</div><div class="line">for item in y_t_3:</div><div class="line">    print item[0],item[1]</div><div class="line">print</div></pre></td></tr></table></figure>
</li>
<li><p>下图是当跨度分别为5,10,15情况下的结果.我们可以看到结果是比较符合我们的预期的,特首(另一个外号),徐逸(bishi真名),睿国(bilibili董事长),逸国,陈睿,9bishi这些词都出现了,冠名说的是b站冠名上海篮球队,体现了word2vec在聚类、找近义词方面强大的功能.在这里没有看出不同跨度下哪组结果更好,实际应用中可能要根据需要进行调节.<br><img src="http://i2.muimg.com/584643/9bd0808703371d6c.png" alt="Markdown"></p>
</li>
<li><p>我们对<code>b站</code>与<code>bishi</code>,<code>bilibili</code>,<code>acfun</code>的余弦相似度进行分析.对这个结果我是不满意的,因为bilibili与b站应该是同一个词,可是相似度却只有40%.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">print model1.similarity(u&apos;b站&apos;,u&apos;bishi&apos;)</div><div class="line">#0.437511023039</div><div class="line">print model1.similarity(u&apos;b站&apos;,u&apos;bilibili&apos;)</div><div class="line">#0.405590707607</div><div class="line">print model1.similarity(u&apos;b站&apos;,u&apos;acfun&apos;)</div><div class="line">#0.394401775964</div></pre></td></tr></table></figure>
</li>
<li><p>然后我试了一下<code>bilibili</code>与<code>哔哩哔哩</code>,<code>B站</code>,<code>弹幕</code>的余弦相似度,发现只有第一个令我满意.可能是语料不够充分的原因.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">print model1.similarity(u&apos;bilibili&apos;,u&apos;哔哩哔哩&apos;)</div><div class="line">#0.90745918569</div><div class="line">print model1.similarity(u&apos;bilibili&apos;,u&apos;B站&apos;)</div><div class="line">#0.381251411934</div><div class="line">print model1.similarity(u&apos;bilibili&apos;,u&apos;弹幕&apos;)</div><div class="line">#0.15385446278</div></pre></td></tr></table></figure>
</li>
<li><p>接下来做个比较有意思的实验: <code>弹幕</code>+<code>刷屏</code>-<code>字幕</code>=?,结果如下,还是比较科学的,都是经常出现在弹幕中的词.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">和谐 0.669674515724</div><div class="line">撕逼 0.629316687584</div><div class="line">热闹 0.627753138542</div><div class="line">游客 0.595176875591</div><div class="line">莫名其妙 0.585232615471</div><div class="line">弹幕礼仪 0.583511531353</div><div class="line">喷子 0.583252549171</div><div class="line">习惯 0.570423543453</div><div class="line">屏蔽 0.568080067635</div><div class="line">动不动 0.565914690495</div></pre></td></tr></table></figure>
</li>
<li><p>接下来做实验,找出集合中不同类的词:输出bishi,没问题,嗯..(要是有问题我就要怀疑数据集了)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list = [u&apos;b站&apos;, u&apos;bishi&apos;, u&apos;哔哩哔哩&apos;, u&apos;B站&apos;,u&apos;bilibili&apos;]</div><div class="line">print model1.doesnt_match(list) #自然是西瓜咯</div><div class="line">#bishi</div></pre></td></tr></table></figure>
</li>
<li><p>word2vec的基本用法就介绍到这里了,大家也可以弄点数据来玩玩,算法细节有精力的也可以深究.</p>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://blog.csdn.net/jerr__y/article/details/52967351" target="_blank" rel="external">python 下的 word2vec 学习笔记</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26218472" target="_blank" rel="external">挖掘1000万字知乎答案，我们到底给川普起了哪些外号？</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i2.muimg.com/584643/ee5427f32c65bc73.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="python" scheme="https://yoghurt-lee.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://yoghurt-lee.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="数据分析" scheme="https://yoghurt-lee.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="word2vec" scheme="https://yoghurt-lee.github.io/tags/word2vec/"/>
    
  </entry>
  
  <entry>
    <title>百里毅行</title>
    <link href="https://yoghurt-lee.github.io/2017/04/24/%E7%99%BE%E9%87%8C%E6%AF%85%E8%A1%8C/"/>
    <id>https://yoghurt-lee.github.io/2017/04/24/百里毅行/</id>
    <published>2017-04-24T14:04:57.000Z</published>
    <updated>2017-04-24T22:15:32.592Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i2.muimg.com/584643/3031cdd864486cc5.jpg" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>20岁之前,来一场说走就走的百里毅行.</p>
</blockquote>
<h3 id="第二篇随笔"><a href="#第二篇随笔" class="headerlink" title="第二篇随笔"></a>第二篇随笔</h3><ul>
<li>连续两篇随笔了,本来这篇是关于介绍word2vec的,星期五的时候我都已经在写了,但是写一篇百里毅行的博客我感觉更有意义，先拖着吧233<br><img src="http://i2.muimg.com/584643/1f707070b3a96e2e.png" alt="Markdown"></li>
</ul>
<h3 id="立了三年的Flag"><a href="#立了三年的Flag" class="headerlink" title="立了三年的Flag"></a>立了三年的Flag</h3><p>大一的时候,我和大黄就开始了百里毅行的策划,可是一直拖着,立了好多flag，可是由于各种原因一直没行动,一直拖到了青春的尾巴.还过几天我们就20岁了,但是,这次我们幸运的抓住了机会.<br><br>4.22,我们开始了百里毅行之旅.<br></p>
<h3 id="长沙to湘潭"><a href="#长沙to湘潭" class="headerlink" title="长沙to湘潭"></a>长沙to湘潭</h3><p>5点半起床,6点出发,7点多一点赶到洋湖湿地公园,现场已经聚集了几万人,但是由于我们是从不同的地方出发的,所以一直找不到对方(其实就隔了一个舞台),这就造成了我们几乎到8点才动身.<br><br><img src="http://i1.piimg.com/584643/c4917a2f4ab27071.jpg" alt="Markdown"><br>我还是很开心的,天气不错,路边风景不错,边上的小姐姐比路上的风景好看,让我感觉这趟来得真值(○’ω’○)。<br><br>放张wuli大黄的照骗.<br><br>.<br><br>.<br><br>.<br><br>.<br><br>.<br><br>.<br><br>.<br><br>.<br><br><img src="http://i1.piimg.com/584643/1eee07fbb140412a.jpg" alt="Markdown"><br>等等,放错了,哈哈.<br><br>本人不要我放照骗.其实跟这个差不多啦，大家自由发挥想象.ヾ(o◕∀◕)ﾉ。<br><br><img src="http://i1.piimg.com/584643/1bf0f0f7eaa3b6ad.jpg" alt="Markdown"><br>从出发点到第二个签到点差不多用了4个小时,这一段路还是比较轻松的,虽然有一段路很难走,但只要不怕脏还是很容易就能过去.<br><br>到了第二个签到点,吃了个中饭我们就继续上路了.但是,折磨马上就要开始了.<br><br>接下来就进入了这一天最煎熬的时刻,一条没有看不到尽头的水泥路,和天上的”温暖”太阳,我穿了一双又硬又重的登山鞋(这里奉劝一句走百里毅行千万别穿登山鞋),在水泥路上脚马上被磨出了水泡,而且还破掉了,脚底变得疼痛无比,走路也变得十分困难,一直坚持到第三个签到点,实在是撑不住了,找了一根木棍支撑着。<br><br>在第三个签到点,工作人员说:还有15KM到达今天的休整点———湖南工程学院,当时我就感觉好绝望啊,脚底起泡,这怎么走的完.<br><br>最后的一段路真是靠意志力才走完的,无比煎熬.脚疼反而变成次要的了,主要是腰疼得不行,始终看不到终点,每次过了一座桥,然后目标又变成了下一座桥,真的感觉快坚持不了了.(但是到最后一个桥的时候可能是看到了希望?整个人突然变得有精神了(ง •̀_•́)ง).这里要给HJJ一万个赞,在腰疼得不行的情况下依然没选择放弃,选择了继续第二天的旅程.不过我们的小姐姐真是后知后觉:一直说脚底没起水泡,结果到了休整点才发现也起了好多水泡.给红十字会点个赞.<br><br>晚上的话睡的是帐篷,第一次睡帐篷,睡在里面没想象中的冷,只不过第二天起来的时候发现外面的布料都被露水弄湿了,走出去差点把我冻死.<br></p>
<h3 id="湘潭to株洲"><a href="#湘潭to株洲" class="headerlink" title="湘潭to株洲"></a>湘潭to株洲</h3><p>第二天的目标是株洲体育中心,距离比第一天近那么一丢丢(但还是超级远),这给了我一点点的安慰.趁着早上有微风,太阳还没出来,我们开始了第二天的毅行.<br><br>但是,我真的是要吐槽啊!这是组委会故意安排的吗?前面十多公里全部都是砾石路 (ノ｀Д´)ノ,本来脚就受伤了,这样的路走起来更是痛苦无比,全程靠木棍撑着走.<br><br>历经千辛万苦,终于走完了砾石路,接下来是漫天灰尘的泥巴路,然后是一座巨长长长的桥啊~第一次感觉桥那么长,不过走过了桥之后,终于迎来了中饭点,不过在这个地方整个人就没动力了,躺在阴凉的地方休息了很久,只想做咸鱼的我们被队伍甩在了后面(＃°Д°)(我能怎么办,我也很绝望啊(°ー°〃))<br><br>接下来就真的是长路漫漫了,正午毒辣的太阳,以及所剩无几的体力,每次走1千多步就要修整一下.我们几乎靠搀扶着才坚持走完了后面的距离,我感觉自己的体能已经到极限了,人不逼自己一把都不知道自己原来可以这么NB.<br><br>总而言之,我们最后完成了百公里毅行，而我也变成了一个非洲小哥(以后还怎么抽卡啊摔),由于太惦记终点站的可乐差点把车票弄丢(幸亏没弄丢,不然只怕是要被一抹多打死<em>(┐「ε:)</em> )<br><br>晚上顺利回到了学校,不过我为什么要作死点了个爆辣黄焖鸡(可能是已经不清醒了),结果是挑战爆辣黄焖鸡失败.回到寝室洗完澡,然后休息了一天写下了这篇文章.<br></p>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ul>
<li>一定不要穿登山鞋,最好是穿鞋底厚一点的户外运动鞋.</li>
<li>早点准备一根可以分担身体重量的拐杖,不然的话当你的脚被磨出泡的时候就已经晚了.</li>
<li>不要带太多东西,但是最好是带一把遮阳伞,带一瓶防晒霜(特别是女生),像我就是太小看春天的太阳了,现在差不多就是肯尼亚小哥了.<em>(┐「ε:)</em></li>
<li>爱护环境,不要随手乱扔垃圾.<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><b>百里毅行真的很锻炼人的意志力,很值得去参加,但是,一次就够了.</b></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i2.muimg.com/584643/3031cdd864486cc5.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="随笔" scheme="https://yoghurt-lee.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>寄给未来的一封信</title>
    <link href="https://yoghurt-lee.github.io/2017/04/17/%E5%A4%A7%E4%B8%89%E7%9A%84%E4%BD%A0/"/>
    <id>https://yoghurt-lee.github.io/2017/04/17/大三的你/</id>
    <published>2017-04-17T14:41:45.000Z</published>
    <updated>2017-04-18T04:43:45.853Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i4.buimg.com/584643/2d17456c9c8ea663.jpg" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>如果能重来,我要选李白</p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27538415&auto=0&height=66"></iframe>

<p>许久没更新博客,今天想来说说迄今为止的大学生活.寄给未来的自己.<br><br>这篇博客——不聊技术,只聊人生.</p>
<p>自从备考研究生以来,总是有点患得患失.想抽时间学习新的技术,抽不出来,每天只能在忙里偷闲.花点零碎的时间抓紧学习.人啊,总是这样,只有在资源稀缺的时候才能感受到珍贵.所以年轻的时候要好好爱惜身体,健康可不能成为稀缺资源.一直纠结于考学硕还是专硕,可是由于高考数学的前车之鉴,我已经没有赌一把的勇气了.</p>
<p>让我跟随时间线回溯,重温一遍大学生活.</p>
<h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>9月,刚进校园.<br><br>一直沉浸在高考数学失利中的我并没有期待大学生活,心里面想的就是度过这四年,然后考研究生证明自己.当我顶着烈日来到农大时,心情自然是很低落的.当我看到十人寝室时,感觉头顶的烈日要把我烤焦了.<br><br>军训过后,那股喊口号的劲头还没过去,于是精神还是很亢奋的我选择了进入校学生会,然后他们做了一个很正确的决定——把我刷掉了.这在当时看来是很失落的,可是现在看起来这是个无比正确的决定,然后我加入了院里的ACM实验室.<br><br>毫无疑问,大一的我并没有自学能力.总觉得什么东西到时候自然会有人教,进了实验室之后当然感觉自己应该努力一把,于是天天刷学校自己的OJ,现在看来,可以将当时的状态称之为——温水煮青蛙.<br><br>在实验室的时候,本院别的专业的人,我总是发现他们做题比我牛,然后我就会自己安慰自己,肯定是他们老师教过,我到暑假集训的时候自然就会了.我甚至还想去蹭他们的课,一点都没想到自身的原因.一直处于这种状态,以至于在OJ上刷了近200道题的我,连贪心,递归都不会,更别说高层次的算法了.<br><br>最后的结果是,弄了一个暑假的ACM,去省赛,什么都没捞着,做出来三个题,顺便提一下,铜奖最少要五道.<br><br>现在回想起大一的时候,完全就是陷入了一种不会学习但是自我满足的状态.当时学长跟我说<code>计算机组成原理</code>重要,于是我去借了那本书,可是根本看不懂也没兴趣,自然什么都没学会.<br><br><b>反正,大一从图书馆借了很多书,没一本看完的.</b><br></p>
<p>大一无疑是失败的一年,现在回想起来教训有几点:</p>
<ul>
<li>大学不应该依靠别人,而是应该依靠自己,培养自学能力,这很重要,不要总是对别人抱有过高的期望.现在在我这个角度看问题,其实学校的老师是很水的,他们绝对没有那个带你拿奖的水平.</li>
<li>一定要在更高的位置上看待问题,在层次低的地方待久了就真的是温水煮青蛙了.</li>
<li>别人比你牛(不说那种智商直接吊打的),只是别人比你努力很多罢了.</li>
</ul>
<h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>大一省赛的失败还是有点激励作用的,不过,我把原因归咎到了一道花了我们队很多时间但是用<code>Java</code>自带的<code>BigDecimal</code>就可以很快做出来,我认为要不是那个题耗费了很多时间,后面还是可以多做一点题的.然后我技能树点歪了,整整一个学期都在学习<code>Java</code>,但是也是有点用的,我的Java掌握的熟练程度还是不错的,然后用它做了人生第一款小游戏——2048.<br><br>然后大二下学期就正式开始了刷题之旅,到省赛之前几乎没休息过,但是人总是要有一个积淀过程的，在半年多的时间内我刷了几百道题,打开了算法世界的大门,也知道了动态规划,图论,线段树,网络流等经典算法.但是由于时间所限,并没有对所有算法都理解的特别深刻.<br><br>最大的收获还是在这段时间培养的自学能力,在碰到一个题目时,自动的去学习算法,查资料,看论文.收集模板.看到一个<code>accept</code>出现的时候兴奋的呐喊,一直<code>worry answer</code>的时候<code>debug</code>的焦虑,看题解的时候的恍然大悟.无疑是我大学中最为宝贵的经历.<br><br>努力最终还是还是有回报的,在第二年的省赛我们拿了二等奖第一名,虽然有遗憾.但也问心无愧.<br><br>省赛过后我们也是抱着试一试的心态打了几场区域赛的网络赛,没想到杭州赛区的竟然打进去了(弱校还未曾进入过区域赛).于是用了学校里的钱来了一次公费旅游,虽然与奖擦肩而过,但是也不得不承认这是实力所限,别人训练的时间真的比我们要多很多.<br><br>大二给人的成长的巨大的,浮躁的心态解决不了任何问题.任何事情只要用心去做不管结果如何你都会有收获.</p>
<h3 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h3><p>大三来临,平淡的日子又来了.<br><br>上学期然后在无聊的生活中我开始了技术的探索,于是通过自学熟悉了<code>python</code>,并且发现这门语言是如此的有趣.同时用它来做一些爬虫,爬爬文本和图片.然后通过各种方法对数据进行处理分析.做一些自动化的小工具完成生活中的工作.然后拿到了驾照和软考证书.在这种生活中我突然发现,大学竟然度过了一多半，留给我们的日子已经很少了,虽然我还是没能喜欢上这所大学.<br><br>在这种生活中,我突然发现我恐慌了,因为我没做过项目,说不定开发能力还不如别人.而我也并不喜欢那种流水线式的开发,我更热爱数据处理,人工智能.我希望我的眼界更开阔,希望我大学所坚持的算法能在我的工作中占有一席之地.我只有去更高的平台,才能有机会去获取到这些资源.然后我做了个决定(其实高考之后就立下了flag)——考研.<br><br>进入下学期,也就是现在.我发现考研的话必须要克服一块硬骨头——英语.英语是我多年的一块心病(差点没过四级).但是我觉得,从零开始就从零开始吧!就像学算法一样,只要有恒心,努力就会有回报.<br><br><b>先定一个小目标:下学期过六级!</b><br><br>但是我不敢赌,我选择了一条比较容易走的道路——专硕.我这把一定要赢,因为这是最后的机会了.希望未来的我看到这里的时候不会想跳起来打我.同时,希望我考上研后,能说出我心中的一个秘密.<br><br>大学三年,感觉自己变成熟了不少,但是还远远不够.人生充满了遗憾,但是不去拼一把也不会收获秋天的果实.<br></p>
<p>最后,送一幅画给大家.</p>
<p><img src="http://i4.buimg.com/584643/67bcf71dcf24cf7c.jpg" alt="Markdown"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i4.buimg.com/584643/2d17456c9c8ea663.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="随笔" scheme="https://yoghurt-lee.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>利用networkx实现图的可视化(实现三种基础的图算法)</title>
    <link href="https://yoghurt-lee.github.io/2017/03/30/graph-visible/"/>
    <id>https://yoghurt-lee.github.io/2017/03/30/graph-visible/</id>
    <published>2017-03-30T10:55:48.000Z</published>
    <updated>2017-04-01T23:01:32.968Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i2.muimg.com/584643/8a2afd1372751550.jpg" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>前言：很久没更新博客了,想找点东西做做,找到一个不错的python数据分析包——networkx,这里就来用它实现最短路的可视化.</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><p>没有安装<code>matplotlib</code>的同学,先去安装对应的版本,我很早之前安装的,也忘记当时是怎么装的了(好像直接利用pip太大了?).</p>
</li>
<li><p>然后安装networkx,运行命令<code>pip install networkx</code>,如果timeout多试几次或者直接去官网下载.</p>
</li>
</ul>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><ul>
<li>网上有个很好的<a href="http://blog.sciencenet.cn/home.php?mod=space&amp;uid=404069&amp;do=blog&amp;id=337442" target="_blank" rel="external">学习资源</a>,如果想详细了解这个类可以去这里学习.我这里只做简单介绍.</li>
<li><p>基本的添加点和边的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">G = nx.DiGraph() #生成有向图</div><div class="line">G = nx.Graph() #生成无向图</div><div class="line">G.add_node(idx) #添加单个节点</div><div class="line">G.add_edge(u,v) #添加单条无权值得边</div><div class="line">G.add_edges_from([(u1,v1),(u2,v2),(u3,v3)]) #添加一个无权的边的集合</div><div class="line">G.remove_edge(u,v) #从图中移除边</div><div class="line">G.remove_node(idx) #从图中移除点</div></pre></td></tr></table></figure>
</li>
<li><p>四种基本的<a href="http://www.cnblogs.com/forstudy/archive/2012/03/20/2407954.html" target="_blank" rel="external">网络模型</a>以及一种自定义网络模型,分别调用如下样式可以深层对应图形.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#规则图</div><div class="line">pos = nx.spectral_layout(G)</div><div class="line"></div><div class="line">#ER随机图</div><div class="line">pos = nx.shell_layout(G)</div><div class="line"></div><div class="line">#WS小世界网络</div><div class="line">pos = nx.circular_layout(G)</div><div class="line"></div><div class="line">#BA无标度网络</div><div class="line">pos = nx.spring_layout(G)</div><div class="line"></div><div class="line">#自定义网络模型:可以规定node的坐标,点太多不适用,最适合二分图</div><div class="line">G.add_node(idx1,pos=(x1,y1))</div><div class="line">G.add_node(idx2,pos=(x2,y2))</div><div class="line">G.add_node(idx3,pos=(x3,y3))</div><div class="line">pos=nx.get_node_attributes(G,&apos;pos&apos;)</div></pre></td></tr></table></figure>
</li>
<li><p>显示点和边</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 显示点:参数分别代表当前图对象,采用的网络模型,节点的大小,节点的颜色</div><div class="line">nx.draw_networkx_nodes(G,pos,node_size=200, node_color=&apos;orange&apos;)</div><div class="line"></div><div class="line"># 显示边:前两个参数同点,edgelist代表当前图中的特定边的集合,arrow代表是否显示边的方向,width代表边的宽度,edge_color代表边的颜色,alpha代表边的透明度(默认为1不透明),以及样式(dashed代表虚线,默认为实线)</div><div class="line">nx.draw_networkx_edges(G,pos,edgelist=e_origin, arrows=True,width=1, edge_color=&apos;g&apos;,alpha=1,style=&apos;dashed&apos;)</div><div class="line">#为图上的节点添加编号标签</div><div class="line">nx.draw_networkx_labels(G,pos,font_size=10,font_family=font)</div><div class="line">#为图里的边添加标签信息(前提是边有标签)</div><div class="line">nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)</div></pre></td></tr></table></figure>
</li>
<li><p>先介绍到这里,因为代码只需要这么多,因为networkx是支持matplotlib的,最后调用<code>plt.show()</code>就能显示图片了.</p>
</li>
</ul>
<h2 id="需要实现的三种算法"><a href="#需要实现的三种算法" class="headerlink" title="需要实现的三种算法"></a>需要实现的三种算法</h2><h3 id="利用spfa算法构造最短路"><a href="#利用spfa算法构造最短路" class="headerlink" title="利用spfa算法构造最短路"></a>利用spfa算法构造最短路</h3><ul>
<li>networkx非常强大,提供最短路算法,但是为了满足需要,我还是自己实现了spfa算法.spfa算法我不详细叙述了,就是利用链式前向星求最短路的算法.这里的话我只说下我的基本思路.</li>
<li>在spfa算法中用一个pre数组存当前节点的前一个节点的编号,以及用一个边编号数组存当前的两个节点中哪一条边被用了(考虑重边问题),节点的d值变了就更新这两个数组的数据;</li>
<li>找完最短路后,然后通过反向寻找路径将用到的边存到一个集合,将之前的边删除掉.然后生成新的边(着两条边本质上是一样的),这样就可以将边分为两个集合(最短路中的边和原图中的边),然后就可以轻易的画出图形了.<br><img src="http://i2.muimg.com/584643/dc9be2d43713c743.png" alt="Markdown"></li>
</ul>
<h3 id="利用prim算法构造最小生成树"><a href="#利用prim算法构造最小生成树" class="headerlink" title="利用prim算法构造最小生成树"></a>利用prim算法构造最小生成树</h3><ul>
<li>这里我就用了邻接矩阵实现的prim算法,prim算法不做介绍.同样是用一个pre数组记录最小生成树中的边,这里的边可以在每次更新的权值的时候就找到.</li>
<li>这个算法不复杂,大家可以扩展一下生成次小生成树.<br><img src="http://i1.piimg.com/584643/c12f839583a9ac9e.png" alt="Markdown"></li>
</ul>
<h3 id="利用匈牙利算法实现二分图的最大匹配"><a href="#利用匈牙利算法实现二分图的最大匹配" class="headerlink" title="利用匈牙利算法实现二分图的最大匹配"></a>利用匈牙利算法实现二分图的最大匹配</h3><ul>
<li>二分图的最大匹配算法实质上也就是寻找增广路的过程,这其中有个linker数组,初始值为-1,当对每个点做完增广后,遍历linker数组,如果linker数组不为-1,则证明这个linker[v]和v形成了匹配.这条边最大匹配中的边.</li>
<li>这个算法可以用链式前向星或者邻接矩阵实现.我这里用的链式前向星.<br><img src="http://i1.piimg.com/584643/4a1335d537734da3.png" alt="Markdown"></li>
</ul>
<h2 id="利用networkx生成图片"><a href="#利用networkx生成图片" class="headerlink" title="利用networkx生成图片"></a>利用networkx生成图片</h2><ul>
<li>这里的话所有的边都是在一个图里面的,怎么区分出来呢?我们发现边里面可以传一个<code>**attr</code>的关键字参数,所以我们可以为两种边设置不同的关键字<code>weight</code>来区分(当然设置别的属性也可以)</li>
<li>我在这里封装了一个模板,按照要求设置好边的<code>label</code>和<code>weight</code>后生成图片.</li>
<li>show函数包含四个参数,G代表networkx生成的图对象,pos代表图的网络模型(默认ER随机图),title表示生成的图图里面所附带的title信息,photo_name代表保存的时候图的名称.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#coding:utf-8</div><div class="line">import networkx as nx</div><div class="line">import matplotlib.pyplot as plt</div><div class="line">#此段代码解决 1.matplotlib中文显示问题 2 &apos;-&apos;显示为方块问题</div><div class="line">from pylab import *</div><div class="line">mpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;]</div><div class="line">mpl.rcParams[&apos;axes.unicode_minus&apos;] = False</div><div class="line"></div><div class="line">def show(G,pos,title=None,photo_name=&apos;picture&apos;):</div><div class="line">    e_1 =[(u,v) for (u,v,d) in G.edges(data=True) if d[&apos;weight&apos;] ==1] # 普通边</div><div class="line">    e_2 =[(u,v) for (u,v,d) in G.edges(data=True) if d[&apos;weight&apos;] ==0] # 利用的边</div><div class="line">    # Draw nodes</div><div class="line">    nx.draw_networkx_nodes(G,pos,node_size=300, node_color=&apos;orange&apos;)</div><div class="line">    # Draw Edges</div><div class="line">    nx.draw_networkx_edges(G,pos,edgelist=e_1,width=1, alpha = 1,edge_color=&apos;g&apos;,style=&apos;dashed&apos;)</div><div class="line">    nx.draw_networkx_edges(G,pos,edgelist=e_2, width=3,alpha=0.6,edge_color=&apos;b&apos;)</div><div class="line">    edge_labels =dict([((u, v), d[&apos;label&apos;]) for u, v, d in G.edges(data=True)])</div><div class="line">    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)</div><div class="line">    nx.draw_networkx_labels(G,pos,font_size=10)</div><div class="line">    plt.title(title)</div><div class="line">    plt.axis(&apos;off&apos;)</div><div class="line">    plt.savefig(photo_name)</div><div class="line">    plt.show()</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i2.muimg.com/584643/8a2afd1372751550.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="networkx" scheme="https://yoghurt-lee.github.io/tags/networkx/"/>
    
      <category term="数据分析" scheme="https://yoghurt-lee.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>(500 lines or less)利用python做一个模板引擎(下)</title>
    <link href="https://yoghurt-lee.github.io/2017/03/16/template-engine-2/"/>
    <id>https://yoghurt-lee.github.io/2017/03/16/template-engine-2/</id>
    <published>2017-03-16T07:15:04.000Z</published>
    <updated>2017-03-16T09:51:12.420Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i1.piimg.com/584643/e965098c222f906a.jpg" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>上篇介绍了整个模板引擎的设计思路,这篇我们将讨论整个代码的具体实现,大牛的代码整体思路以及风格非常值得借鉴.<br>ps:由于代码是本人学习完之后自己敲的,如果有错误之处请指出,<a href="https://github.com/yoghurt-lee/template-engine" target="_blank" rel="external">code</a>.</p>
</blockquote>
<h3 id="CodeBuilder类"><a href="#CodeBuilder类" class="headerlink" title="CodeBuilder类"></a>CodeBuilder类</h3><ul>
<li><p>该类实现代码的拼接以及解释python代码返回一个<code>dict</code>.由于该类的实现参考博客以及说得非常详细了,我这里只说一下我觉得需要讲的地方.</p>
</li>
<li><p><code>add_section</code>方法,我感觉这个函数设计得非常巧妙,因为当我们用传入的模板生成python代码的时候,我们是不知道全部变量名,所以只能一边分析一边生成变量名.所以我们要保留一块位置放置变量名。该函数生成了一个新的CodeBulider对象在旧的对象中保留了一个参考位置并保留了参考位置的缩进.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def add_section(self):</div><div class="line">    section = CodeBulider(self.indent_level)</div><div class="line">    self.code.append(section)</div><div class="line">    return section</div></pre></td></tr></table></figure>
</li>
<li><p><code>get_global</code>方法,这个方法调用了<code>exec()</code>,该函数执行一串包含python代码的字符串，它的第二个参数是一个字典，用来收集字符串代码中定义的全局变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def get_global(self):</div><div class="line">      # 确保整个代码结束后的缩进等级为 0</div><div class="line">      assert self.indent_level == 0</div><div class="line">      code = str(self)</div><div class="line">      namespace = &#123;&#125;</div><div class="line">      exec(code,namespace)</div><div class="line">      return namespace</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Templite类"><a href="#Templite类" class="headerlink" title="Templite类"></a>Templite类</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li><p>该类是模板引擎的核心类,该类构造函数接收两个参数<code>text</code>以及<code>*contexts</code>,星号表示任意数量的位置参数将被打包成一个元组作为contexts传递进来。称为参数解包.可以通过循环遍历取出所有的元素.<code>text</code>即为传入的模板.编译一个模板为python代码的工作都将在构造器里完成.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def __init__(self,text=None,*contexts):</div><div class="line">      self.text = text</div><div class="line">      self.contexts = &#123;&#125;</div><div class="line">      for context in contexts:</div><div class="line">          self.contexts.update(context)</div></pre></td></tr></table></figure>
</li>
<li><p>该类有两个重要的变量,第一个是保存代码中所有出现过的变量,第二个是循环中出现的变量,因为循环中出现过的变量是无需定义成上下文变量的,所以最后在所有变量中除去循环变量即为所需定义的上下文变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">self.all_vars = set()</div><div class="line">self.loop_vars = set()</div><div class="line">#中间代码省略</div><div class="line">for var_name in self.all_vars - self.loop_vars:</div><div class="line">    vars_code.add_line(&apos;c_%s = context[%r]&apos;%(var_name,var_name))</div></pre></td></tr></table></figure>
</li>
<li><p>使用CodeBulider组建好python代码,这里最值得注意的是<code>vars_code</code>,为变量名提供了一个参考位置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">code = CodeBulider()</div><div class="line">code.add_line(&apos;def render_function(context, do_dots):&apos;)</div><div class="line">code.add_indent()</div><div class="line">vars_code = code.add_section()</div><div class="line">code.add_line(&apos;result=[]&apos;)</div><div class="line">code.add_line(&apos;append_result = result.append&apos;)</div><div class="line">code.add_line(&apos;extend_result = result.extend&apos;)</div><div class="line">code.add_line(&apos;to_str = str&apos;)</div><div class="line">#中间代码省略</div><div class="line">code.add_line(&apos;return &quot;&quot;.join(result)&apos;)</div><div class="line">code.sub_indent()</div></pre></td></tr></table></figure>
</li>
<li><p>缓冲区<code>buffered</code>,作者在这里做了一个微优化,当缓冲数组长度为一行或者多行时选择不同的方法添加字符串.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">buffered = []</div><div class="line">def flush_output():</div><div class="line">    if len(buffered)==1:</div><div class="line">        code.add_line(&apos;append_result(%s)&apos;%(buffered[0]))</div><div class="line">    elif len(buffered)&gt;1:</div><div class="line">        code.add_line(&apos;extend_result([%s])&apos;% &quot;,&quot;.join(buffered))</div><div class="line">    del buffered[:]  #清除缓冲数组</div></pre></td></tr></table></figure>
</li>
<li><p>利用正则表达式匹配出我们需要解析的元素.并且一一对这些元素进行分析.然后利用一个操作符栈,在碰到if或者for时控制代码的缩进.关于每一个条件的处理,这里就不一一赘述了,参考博客讲得很明白.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">re.split(r&quot;(?s)(&#123;&#123;.*?&#125;&#125;|&#123;%.*?%&#125;|&#123;#.*?#&#125;)&quot;, text)</div></pre></td></tr></table></figure>
</li>
<li><p>最后生成的代码以及get_global函数返回的字典分别存在以下两个变量中,至此构造函数完成.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.code = code</div><div class="line">self.render_function = code.get_global()[&apos;render_function&apos;]</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="编译表达式"><a href="#编译表达式" class="headerlink" title="编译表达式"></a>编译表达式</h4><ul>
<li>我们前面说过,模板代码里支持三种形式的表达式:一种是普通变量,一种是普通变量加上通过管道连接的过滤器和通过含有点的表达式.</li>
<li>对于普通变量,我们只需在前面加上<code>-c</code>便可直接返回</li>
<li>对于包含管道的表达式,我们分割管道,然后将第一个变量通过递归调用变成代码中所定义的变量,然后将变量与过滤器进行迭代,得到最终结果</li>
<li>对于包含点操作符的变量,我们分割点,将第一个变量同样通过递归变成代码中所定义的变量,比如 x.y , 我们可能的结果会有 x[‘y’] , x.y&lt;=&gt;getattr(x,’y’) ,以及可调用三种情况，所以我们将其交给<code>do_dots()</code>函数进行处理.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def expr_code(self,expr):</div><div class="line">    if &apos;|&apos; in expr:</div><div class="line">        words = expr.split(&apos;|&apos;)</div><div class="line">        code = self.expr_code(words[0])</div><div class="line">        for func in words[1:]:</div><div class="line">          self.validate(func,self.all_vars)</div><div class="line">        code = &quot;c_%s(%s)&quot;%(func,code)</div><div class="line">    elif &apos;.&apos; in expr:</div><div class="line">        words = expr.split(&apos;.&apos;)</div><div class="line">        code = self.expr_code(words[0])</div><div class="line">        args = &quot;,&quot;.join(repr(c) for c in words[1:])</div><div class="line">        code = &quot;do_dots(%s,%s)&quot; % (code,args)</div><div class="line">    else:</div><div class="line">        self.validate(expr,self.all_vars)</div><div class="line">        code = &quot;c_%s&quot; % expr</div><div class="line">    return code</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h4><ul>
<li>使用<code>_syntax_error()</code>来进行异常处理以及<code>validate()</code>来进行变量名合法性的检测,<code>get_model_code()</code>用来获取生成的python代码.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def _syntax_error(self, msg, thing):</div><div class="line">      raise TempliteError(&quot;%s: %r&quot; % (msg, thing))</div><div class="line"></div><div class="line">def validate(self,word,var_set):</div><div class="line">    if not re.match(r&apos;[_a-zA-Z][_0-9a-zA-Z]*$&apos;,word):</div><div class="line">        self._syntax_error(&quot;var_name is invalid&quot;,word)</div><div class="line">    var_set.add(word) #注意 set 是用 add 方法添加元素</div><div class="line">def get_model_code(self):</div><div class="line">    return self.code</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="do-dots-函数"><a href="#do-dots-函数" class="headerlink" title="do_dots()函数"></a>do_dots()函数</h4><ul>
<li>该方法也就是进行枚举,举个例子,<code>product.name.upper</code>(这里的upper代表upper,假设product是一个字典,name是其元素),最后的结果就是 <code>product[&#39;name&#39;].upper()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def do_dots(self,expr,*args):</div><div class="line">    for word in args:</div><div class="line">        try:</div><div class="line">          expr = expr[word]</div><div class="line">        except:</div><div class="line">          expr = getattr(expr,word)</div><div class="line">        if callable(expr):</div><div class="line">          expr = expr()</div><div class="line">    return expr</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><ul>
<li>这里为什么叫渲染我也不大清楚,但是一时也想不到比较好的名字来形容这个函数.将新传入的<code>context</code>(这个context里面包含的一般是模板变量的值)与之前的<code>context</code>(这里的context一般是模板中的方法重新定义的名字)合并,并且将<code>do_dots()</code>作为参数传入<code>render_function()</code>,这样就可以得到整个代码的返回值了.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def render(self,context=None):</div><div class="line">    if context:</div><div class="line">        self.contexts.update(context)</div><div class="line">    return self.render_function(self.contexts,self.do_dots)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><blockquote>
<p>代码的功能不是很强,可以自己慢慢完善,代码风格是非常值得学习的.作者留给我们的扩展:</p>
</blockquote>
<ul>
<li>模板继承和包含</li>
<li>自定义标签</li>
<li>自动换码</li>
<li>参数过滤器</li>
<li>复杂条件逻辑如else和elif</li>
<li>不止一个循环变量的循环</li>
<li>空白的控制</li>
</ul>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p><a href="http://www.jianshu.com/p/d6551dfacd58" target="_blank" rel="external">从零开始一个模板引擎的python实现——500 lines or less-A Template Engine翻译（下）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i1.piimg.com/584643/e965098c222f906a.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="python" scheme="https://yoghurt-lee.github.io/tags/python/"/>
    
      <category term="模板引擎" scheme="https://yoghurt-lee.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>(500 lines or less)利用python做一个模板引擎(上)</title>
    <link href="https://yoghurt-lee.github.io/2017/03/15/template-engine-1/"/>
    <id>https://yoghurt-lee.github.io/2017/03/15/template-engine-1/</id>
    <published>2017-03-15T15:04:28.000Z</published>
    <updated>2017-03-16T14:14:04.345Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p1.bqimg.com/584643/42394831bda4e97e.jpg" alt="Markdown"></p>
<a id="more"></a>
<blockquote>
<p><a href="https://github.com/aosabook/500lines" target="_blank" rel="external">500 lines or less</a> 是github上一个有14000赞的代码仓库,包含多个小项目,非常适合Python以及其他语言的入门者和进阶者学习.感谢翻译者们做出的贡献,才让我们能够吸收这些好的资源!</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li><p>我这里所写的是自己学习这个项目之后的所感所想,同时也对该文档做一个精简版的说明,如果想详细了解该项目的细节,请移步<a href="http://www.jianshu.com/p/b5d4aa45e771" target="_blank" rel="external">中文文档</a></p>
</li>
<li><p>有时候我们写以文字为主的文件(比如HTML)时,里面大部分都是静态的,但是还是有小部分的文件是动态数据,比如我们想生成这样的一份数据,Hello后面的用户名以及下面的书籍列表是动态生成的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;h1&gt;hello!Lee&lt;/h1&gt;</div><div class="line">&lt;p&gt;book1&lt;/p&gt;</div><div class="line">&lt;p&gt;book2&lt;/p&gt;</div><div class="line">&lt;p&gt;book3&lt;/p&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>我们自然就会用一个这样的函数来处理这些传入的数据来生成HTML</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def make_page(name,book_list):</div><div class="line">  PAGE = &quot;&lt;html&gt;\n&lt;h1&gt;hello!%s&lt;/h1&gt;\n&quot;%name</div><div class="line">  for book in book_list:</div><div class="line">      PAGE += &quot;&lt;p&gt;%s&lt;/p&gt;\n&quot; % book</div><div class="line">  PAGE+=&quot;&lt;/html&gt;&quot;</div><div class="line">  return PAGE</div></pre></td></tr></table></figure>
</li>
<li><p>但是这样做是很麻烦的,不同的页面需要不同的代码,而且将HTML的静态文本分成一块一块的,非常难改动,特别是当页面需要进行变动的时候.</p>
</li>
</ul>
<h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><ul>
<li><p>概念</p>
<blockquote>
<p>模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档(引自百科)。</p>
</blockquote>
</li>
<li><p>如果大家学过Java Web或者别的Web框架会了解模板引擎的概念.将静态文本中的动态数据进行某种标注后,整个模板就会交给后台的逻辑处理代码生成标准的HTML文档(MVC设计模式?).所以模板引擎是以静态文本为主,中间将动态数据用特殊的符号标记,将这份模板传入引擎处理后,模板将变成python代码,然后执行生成最终的静态文本.</p>
</li>
<li><p>综上所述,模板引擎其实就是将我们生成代码的思路从以逻辑为主变成以文本为主.接下来,我们做一个简单的模板引擎.</p>
</li>
</ul>
<h3 id="模板引擎所支持的语法"><a href="#模板引擎所支持的语法" class="headerlink" title="模板引擎所支持的语法"></a>模板引擎所支持的语法</h3><ul>
<li><p>由于是一个最初始的模板引擎,所以我们只提供如下语法支持 (打’{‘老报错,换成’(‘,估计hexo把我这当模板给翻译了 @^@):</p>
<blockquote>
<p>1.(( name|filter1|filter2|..)) : 其中包含的是上下文变量以及过滤器,每一个元素以管道分割,比如说 ((name|upper)) 那么在python代码中就会以upper(name)实现.</p>
<p>2.(%…%): 提供条件判断语句以及循环语句的支持。条件语句和循环语句分别以(%endif%)、(%endfor%)结尾.</p>
<p>3.点操作 : 点操作将有可能出现1和2中,点操作有可能是以下三个操作中的一个.</p>
<ul>
<li>x[‘y’] : 表示 x 是一个字典,y是其中的一个键.</li>
<li>x.y : 表示 y 是 x的一个属性.</li>
<li>x() : 表示x是一个可调用(callable)的方法.代码将自动调用.</li>
</ul>
<p>4.(#…#) : 注释语句,会被翻译成为 &lt;!–…–&gt;.</p>
</blockquote>
</li>
</ul>
<ul>
<li>使用我们的模板将上面的html代码变成模板:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;!&lt;/h1&gt;</div><div class="line">  &#123;% for book in book_list %&#125;</div><div class="line">      &lt;p&gt;&#123;&#123;book&#125;&#125;&lt;/p&gt;</div><div class="line">  &#123;% endfor %&#125;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="引擎所生成的python代码模板"><a href="#引擎所生成的python代码模板" class="headerlink" title="引擎所生成的python代码模板"></a>引擎所生成的python代码模板</h3><ul>
<li><p>我们将使用使用引擎生成如下python代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def render_function(context, do_dots):</div><div class="line">  # 变量名</div><div class="line">  result=[]</div><div class="line">  append_result = result.append</div><div class="line">  extend_result = result.extend</div><div class="line">  to_str = str</div><div class="line">  # 模板所生成的python代码</div><div class="line">  append_result(&apos;\n    &apos;)</div><div class="line">  return &quot;&quot;.join(result)</div></pre></td></tr></table></figure>
</li>
<li><p>上述python代码总的来说就是一个方法,其包含两个参数<code>context</code>和<code>do_dots</code>,<code>context</code>是传入的字典,字典中包含的是HTML中所需要的变量名和变量值,<code>do_dots</code>是处理HTML代码中的点操作的函数.</p>
</li>
<li><p>所有传入的变量名都会以<code>c_</code>开头,以保证不会与python内置方法发生冲突.</p>
</li>
<li><p>还有一个微优化,就是<code>append_result=result.append</code>,这里引用原作者的话:”在模板引擎代码中我们用这种分离的方式是的我们不论做多少次第二步，只用做一次第一步。这节省了我们少量的时间，因为避免了再花时间去查找对象的append属性。”,又学一招(笑)</p>
</li>
<li><p>我们将上面的html模板通过引擎将生成如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def render_function(context, do_dots):</div><div class="line">  c_name = context[&apos;name&apos;]</div><div class="line">  c_book_list = context[&apos;book_list&apos;]</div><div class="line">  result=[]</div><div class="line">  append_result = result.append</div><div class="line">  extend_result = result.extend</div><div class="line">  to_str = str</div><div class="line">  extend_result([&apos;\n    &lt;h1&gt;Hello &apos;,to_str(c_name),&apos;!&lt;/h1&gt;\n    &apos;])</div><div class="line">  for c_book in c_book_list:</div><div class="line">      extend_result([&apos;\n        &lt;p&gt;&apos;,to_str(c_book),&apos;&lt;/p&gt;\n    &apos;])</div><div class="line">  append_result(&apos;\n    &apos;)</div><div class="line">  return &quot;&quot;.join(result)</div></pre></td></tr></table></figure>
</li>
<li><p>在下一篇博客我们将讨论代码的具体实现.</p>
</li>
</ul>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p><a href="http://www.jianshu.com/p/b5d4aa45e771" target="_blank" rel="external">从零开始一个模板引擎的python实现——500 lines or less-A Template Engine翻译（上）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p1.bqimg.com/584643/42394831bda4e97e.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="python" scheme="https://yoghurt-lee.github.io/tags/python/"/>
    
      <category term="模板引擎" scheme="https://yoghurt-lee.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>使用wordcloud统计标签数据</title>
    <link href="https://yoghurt-lee.github.io/2017/03/08/python-wordcloud/"/>
    <id>https://yoghurt-lee.github.io/2017/03/08/python-wordcloud/</id>
    <published>2017-03-08T15:10:19.000Z</published>
    <updated>2017-03-11T05:44:15.176Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p1.bqimg.com/584643/d4a2b4f728fa8e1b.jpg" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>标签利器:wordcloud(词云),一起来学(zhuang)习(bi)吧!</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>安装wordcloud包,<code>pip install wordcloud</code>,如果需要对文本的句子进行分解,比如说<code>我是一名大学生</code>进行分解之后就变成了<code>我是\一名\大学生</code>.可以安装jieba,同运行<code>pip install jieba</code>.</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>安装完之后,我们来运行一个Demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">#-*- coding: utf-8 -*-</div><div class="line"></div><div class="line">&quot;&quot;&quot;</div><div class="line">Using custom colors</div><div class="line">====================</div><div class="line">Using the recolor method and custom coloring functions.</div><div class="line">&quot;&quot;&quot;</div><div class="line">import matplotlib.pyplot as plt</div><div class="line">import random</div><div class="line">import os</div><div class="line">from wordcloud import WordCloud, STOPWORDS</div><div class="line"></div><div class="line">#此段代码解决 1.matplotlib中文显示问题 2 &apos;-&apos;显示为方块问题</div><div class="line">from pylab import *</div><div class="line">mpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;]</div><div class="line">mpl.rcParams[&apos;axes.unicode_minus&apos;] = False</div><div class="line"></div><div class="line">font=os.path.join(os.path.dirname(__file__), &quot;FZSTK.ttf&quot;)</div><div class="line"></div><div class="line">text = open(u&quot;test.txt&quot;).read().decode(&apos;gbk&apos;)</div><div class="line"># adding movie script specific stopwords</div><div class="line">stopwords = set(STOPWORDS)</div><div class="line">stopwords.add(&quot;int&quot;)</div><div class="line">stopwords.add(&quot;ext&quot;)</div><div class="line"></div><div class="line">#wc = WordCloud(font_path=font,max_words=2000, mask=mask, stopwords=stopwords, margin=10,random_state=42,max_font_size=20,background_color=&apos;black&apos;,scale =2).generate(text)</div><div class="line">wc = WordCloud(font_path=font,max_words=30, max_font_size=50,stopwords=stopwords,margin=10,random_state=42,background_color=&apos;black&apos;,scale =1).generate(text)</div><div class="line"># store default colored image</div><div class="line">default_colors = wc.to_array()</div><div class="line">wc.to_file(&quot;a_new_hope.png&quot;)</div><div class="line">#设置为 wordcloud 默认</div><div class="line">plt.title(&apos;WordCloud Demo&apos;)</div><div class="line">plt.imshow(default_colors)</div><div class="line">plt.axis(&quot;off&quot;)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
</li>
<li><p>运行结果<br><img src="http://p1.bqimg.com/584643/bb7398429e01d188.png" alt="Markdown"></p>
</li>
<li><p><code>wordcloud</code>里面的基本参数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">WordCloud(font_path=None, width=400, height=200, margin=5, ranks_only=False, prefer_horizontal=0.9,mask=None, scale=1, color_func=&lt;function random_color_func at 0x2b8b422a31b8&gt;, max_words=200, stopwords=None,random_state=None, background_color=&apos;black&apos;, max_font_size=None)</div><div class="line"></div><div class="line">#font_path:用到的字体文件的路径（支持OTF或TTF格式）.默认字体是DroidSansMono,但是不能够显示中文,所以可以Windows系统下的C:\Windows\Fonts中找字体替换.</div><div class="line">#width:画布宽度,默认值为400</div><div class="line">#height:画布高度,默认值为200</div><div class="line">#ranks_only:是否只用词频排序而不是实际词频统计值，默认 False</div><div class="line">#prefer_horizontal:词语水平出现的频率，默认0.9（即垂直出现频率为0.1）</div><div class="line">#mask: nd-array or None (default=None)如果参数为空，则使用二维遮罩绘制词云.如果mask非空，设置的宽高值将被忽略，遮罩形状被 mask 取代.除全白（#FFFFFF）的部分将不会绘制，其余部分会用于绘制词云。</div><div class="line">#scale : float (default=1)计算与绘制图像间的比例。对于较大的词云图像，使用比例而非较大的画布会显著提升绘图速度，但是可能会造成词语间的粗糙拟合。</div><div class="line">#max_words :(default=2000)词语的最大数量</div><div class="line">#stopwords : set of strings 屏蔽词</div><div class="line">#max_font_size : int or None (default=None)最大词的最大字号.</div></pre></td></tr></table></figure>
</li>
<li><p><code>wordcloud</code>里面的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#static fit_words(frequencies) / generate_from_frequencies: 依据词语和频率生成词云.</div><div class="line">参数：frequencies : array of tuples(包含了词语和频率的元组.)</div><div class="line"></div><div class="line">#static generate(text) / generate_from_text: 从文本中生成词云,调用 _text 和 fit_words.</div><div class="line"></div><div class="line">#static process_text(text): 将长文本分词并去除屏蔽词（此处指英语，中文分词还是需要自己用别的库先行实现，使用上面的 fit_words(frequencies))</div><div class="line">参数：text : string(需要处理的文本)</div><div class="line">返回：words : list of tuples (string, float)(带有相应频率的词语)</div><div class="line"></div><div class="line">#static recolor(random_state=None, color_func=None): 对现有输出重新着色。重新上色会比重新生成整个词云快很多。</div><div class="line"></div><div class="line">#random_state : RandomState, int, or None, default=None</div><div class="line">如果非空，会使用固定的随机状态。</div><div class="line">如果给出一个整数，它会被用作 random.Random 状态的一个种子（根源）</div><div class="line"></div><div class="line">#color_func : function or None, default=None</div><div class="line">生成新颜色的函数，如果为空，则使用 self.color_func</div><div class="line"></div><div class="line">#static to_array():转化为 numpy array</div><div class="line">返回：image : nd-array size (width, height, 3)</div><div class="line">numpy 矩阵的词云图像</div><div class="line"></div><div class="line">#static to_file(filename):输出到文件</div><div class="line">参数：filename : string</div><div class="line">输出的文件路径</div><div class="line"></div><div class="line">#wordcloud.ImageColorGenerator(image): 基于 RGB 图像生成颜色。词语将会使用一定矩形区域内的平均颜色上色。这个对象可以被调用作为词云或者重新上色方法的颜色函数。</div><div class="line">参数：image : nd-array, shape (height, width, 3)(用来生成词语颜色的图像.)</div><div class="line"></div><div class="line">#wordcloud.random_color_func(word=None, font_size=None, position=None, orientation=None, font_path=None, random_state=None):随机生成色调,默认的上色方法。仅仅会生成一个随机的色调(80% 颜色值 50% 亮度)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="使用mask元素绘制图像"><a href="#使用mask元素绘制图像" class="headerlink" title="使用mask元素绘制图像"></a>使用mask元素绘制图像</h3><ul>
<li>我将我的原博客的标签页里的标签做个词云,先利用BeautifulSoup将网页的信息进行解析,然后使用一张心型图做mask生成一张词云.效果如下:</li>
</ul>
<p><img src="http://p1.bqimg.com/584643/ebd6d3c220baec97.png" alt="Markdown"></p>
<ul>
<li><a href="https://github.com/yoghurt-lee/cnblogs_tags_wordcloud/" target="_blank" rel="external">源代码需要的话这里取</a><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><a href="http://www.cnblogs.com/Yiutto/p/5998296.html" target="_blank" rel="external"> Python word_cloud 部分文档翻译</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p1.bqimg.com/584643/d4a2b4f728fa8e1b.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="python" scheme="https://yoghurt-lee.github.io/tags/python/"/>
    
      <category term="数据分析" scheme="https://yoghurt-lee.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="wordcloud" scheme="https://yoghurt-lee.github.io/tags/wordcloud/"/>
    
  </entry>
  
  <entry>
    <title>使用matplotlib对b站前10000名用户做简单分析</title>
    <link href="https://yoghurt-lee.github.io/2017/03/02/Using-Matplotlib-to-analyze-BiliBili-users/"/>
    <id>https://yoghurt-lee.github.io/2017/03/02/Using-Matplotlib-to-analyze-BiliBili-users/</id>
    <published>2017-03-02T04:31:28.000Z</published>
    <updated>2017-03-02T05:00:46.489Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p1.bqimg.com/584643/2f439e08ce66c06a.jpg" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>summary: 在前面几篇文章中我安装了MySQLdb,然后我利用MySQLdb爬取了b站前10000名用户,现在我将使用matplotlib对这些数据做一个简单的数据分析.</p>
</blockquote>
<h3 id="对b站会员的等级分布做一个简单的饼图分析"><a href="#对b站会员的等级分布做一个简单的饼图分析" class="headerlink" title="对b站会员的等级分布做一个简单的饼图分析."></a>对b站会员的等级分布做一个简单的饼图分析.</h3><ul>
<li>在这里我们可以看到b站的等级是分为1-6总共6个等级,其中等级4的人是占比最大的.等级6的人所占人数不过0.31%.<br><img src="http://p1.bqimg.com/584643/29daafe53c68b25b.png" alt="Markdown"></li>
</ul>
<h3 id="对b站会员的粉丝数做一个简单的柱状图分析"><a href="#对b站会员的粉丝数做一个简单的柱状图分析" class="headerlink" title="对b站会员的粉丝数做一个简单的柱状图分析."></a>对b站会员的粉丝数做一个简单的柱状图分析.</h3><ul>
<li><p>我将粉丝人数分为了6个区间,从柱状图可以看到b站的粉丝数是呈现一个递减的趋势,而且0-10粉丝数的人处于最多的那一片.或许这个图的区间还太大了,描述的不够精确.于是我们细分一下区间.<br><img src="http://p1.bqimg.com/584643/afde90a706ad36f0.png" alt="Markdown"></p>
</li>
<li><p>这样的话可以看到图有一点波动,但是还是描述的不够好.<br><img src="http://i1.piimg.com/584643/f5b7eac570ddfb77.png" alt="Markdown"></p>
</li>
</ul>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">#coding:utf-8</div><div class="line">import MySQLdb</div><div class="line">from numpy.random.mtrand import np</div><div class="line"></div><div class="line">import matplotlib.pylab as plt</div><div class="line"></div><div class="line"></div><div class="line">def draw_pie():</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    #函数说明</div><div class="line">    pie(x, explode=None, labels=None,  </div><div class="line">        colors=(&apos;b&apos;, &apos;g&apos;, &apos;r&apos;, &apos;c&apos;, &apos;m&apos;, &apos;y&apos;, &apos;k&apos;, &apos;w&apos;),  </div><div class="line">        autopct=None, pctdistance=0.6, shadow=False,  </div><div class="line">        labeldistance=1.1, startangle=None, radius=None,  </div><div class="line">        counterclock=True, wedgeprops=None, textprops=None,  </div><div class="line">        center = (0, 0), frame = False ) </div><div class="line">    </div><div class="line">     x       (每一块)的比例，如果sum(x) &gt; 1会使用sum(x)归一化</div><div class="line">    labels  (每一块)饼图外侧显示的说明文字</div><div class="line">    explode (每一块)离开中心距离</div><div class="line">    startangle  起始绘制角度,默认图是从x轴正方向逆时针画起,如设定=90则从y轴正方向画起</div><div class="line">    shadow  是否阴影</div><div class="line">    labeldistance label绘制位置,相对于半径的比例, 如&lt;1则绘制在饼图内侧</div><div class="line">    autopct 控制饼图内百分比设置,可以使用format字符串或者format function</div><div class="line">            &apos;%1.1f&apos;指小数点前后位数(没有用空格补齐)</div><div class="line">    pctdistance 类似于labeldistance,指定autopct的位置刻度</div><div class="line">    radius  控制饼图半径</div><div class="line">    </div><div class="line">    返回值:</div><div class="line">    如果没有设置autopct,返回(patches, texts)</div><div class="line">    如果设置autopct,返回(patches, texts, autotexts)</div><div class="line">    </div><div class="line">    patches -- list --matplotlib.patches.Wedge对象</div><div class="line">    </div><div class="line">    texts autotexts -- matplotlib.text.Text对象</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    conn = MySQLdb.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, passwd=&apos;helloworld&apos;, port=3306,db=&apos;bilibili_user&apos;,charset=&apos;utf8&apos;)</div><div class="line">    cur = conn.cursor()</div><div class="line">    level_count = []</div><div class="line">    for i in range(0,6): </div><div class="line">        sql = &apos;select * from user_info where level=&apos;+str(i+1)</div><div class="line">        level_count.append(cur.execute(sql))</div><div class="line">    cur.close()</div><div class="line">    conn.close()</div><div class="line">    labels = [u&apos;Level-1&apos;, u&apos;Level-2&apos;, u&apos;Level-3&apos;, u&apos;Level-4&apos;,u&apos;Level-5&apos;,u&apos;Level-6&apos;]</div><div class="line">    colors = [&apos;red&apos;, &apos;yellow&apos;, &apos;blue&apos;, &apos;green&apos;,&apos;orange&apos;]</div><div class="line">    expl = [0,0,0,0.1,0,0]   #每一块离开圆心的距离 </div><div class="line">    </div><div class="line">    plt.pie(level_count, explode=expl, labels=labels, colors=colors, labeldistance=1.1, autopct=&apos;%.3f%%&apos;, shadow=False)</div><div class="line">    plt.title(&apos;bilibili top 10000 user ratings analysis&apos;)</div><div class="line">    plt.axis(&apos;equal&apos;) #加上这句让 x y 轴相等成为标准的圆</div><div class="line">    plt.legend(loc=&apos;upper left&apos;, bbox_to_anchor=(-0.17, 1.1))</div><div class="line">    plt.show()</div><div class="line">    plt.close() </div><div class="line">    </div><div class="line">def draw_bar():  </div><div class="line">    conn = MySQLdb.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, passwd=&apos;helloworld&apos;, port=3306,db=&apos;bilibili_user&apos;,charset=&apos;utf8&apos;)</div><div class="line">    cur = conn.cursor()</div><div class="line">    fans_count = []</div><div class="line">    fans_num = [0,5,10,100,1000,1000000]</div><div class="line">    labels = [&apos;0&apos;,&apos;1-5&apos;,&apos;6-10&apos;,&apos;11-100&apos;,&apos;101-1000&apos;,&apos;1001-10000&apos;]</div><div class="line">    pre = 0</div><div class="line">    for i in range(len(fans_num)): </div><div class="line">        sql = &apos;select * from user_info where fans&lt;=&apos;+str(fans_num[i])</div><div class="line">        now = cur.execute(sql)</div><div class="line">        fans_count.append(now-pre)</div><div class="line">        pre=now</div><div class="line">    cur.close()</div><div class="line">    conn.close()</div><div class="line">    width = 0.5  </div><div class="line">    ind = np.linspace(0,len(fans_num),len(fans_num))  </div><div class="line">    # make a square figure  </div><div class="line">    fig = plt.figure(1)  </div><div class="line">    ax  = fig.add_subplot(111)  </div><div class="line">    # Bar Plot  </div><div class="line">    ax.bar(ind-width/2,fans_count,width,color=&apos;green&apos;)  </div><div class="line">    # Set the ticks on x-axis  </div><div class="line">    ax.set_xticks(ind)  </div><div class="line">    ax.set_xticklabels(labels)  </div><div class="line">    # labels  </div><div class="line">    ax.set_xlabel(&apos;Fan number interval&apos;)  </div><div class="line">    ax.set_ylabel(&apos;Number of Fans&apos;)  </div><div class="line">    # title  </div><div class="line">    ax.set_title(&apos;bilibili top 10000 users fans&apos;)  </div><div class="line">    plt.grid(True)  </div><div class="line">    plt.show()  </div><div class="line">    plt.close()  </div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    #draw_pie()</div><div class="line">    draw_bar()</div></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>一直对数据分析这个方向比较感兴趣,很想做一点等级与粉丝数的相关性分析,但是现在自己要考研,没时间做深入学习,争取考上研究生能够做数据分析、机器学习方向的研究.</li>
<li>感兴趣的同学可以试下:<a href="https://github.com/yoghurt-lee/bilibili_user_spider" target="_blank" rel="external">b站用户爬虫</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p1.bqimg.com/584643/2f439e08ce66c06a.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="python" scheme="https://yoghurt-lee.github.io/tags/python/"/>
    
      <category term="数据分析" scheme="https://yoghurt-lee.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>(转载)关于反爬虫的一些总结</title>
    <link href="https://yoghurt-lee.github.io/2017/02/28/deal-Anti-crawler/"/>
    <id>https://yoghurt-lee.github.io/2017/02/28/deal-Anti-crawler/</id>
    <published>2017-02-28T04:40:22.000Z</published>
    <updated>2017-09-14T07:36:57.705Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://a1.qpic.cn/psb?/V12rrNui2Gg6Y1/A.1u6LfnKovXteRCYu8iuz3GJ5MSahfm31g9MFHyaYs!/b/dHUAAAAAAAAA&amp;bo=OQSAAgAAAAARAIg!&amp;rf=viewer_4" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>summary: 在知乎上看到的一篇比较全面的解决反爬虫问题的文章,看完感觉有很多收获,遂转载到我的博客.</p>
</blockquote>
<h3 id="爬取过程中的302重定向"><a href="#爬取过程中的302重定向" class="headerlink" title="爬取过程中的302重定向"></a>爬取过程中的302重定向</h3><ul>
<li><p>在爬取某个网站速度过快或者发出的请求过多的时候，网站会向你所在的客户端发送一个链接，需要你去验证图片。</p>
</li>
<li><p>对于302重定向的问题，是由于抓取速度过快引起网络流量异常，服务器识别出是机器发送的请求，于是将请求返回链接定到某一特定链接，大多是验证图片或空链接。</p>
</li>
<li><p>在这种时候，既然已经被识别出来了，就使用代理ip再继续抓取。</p>
</li>
</ul>
<h3 id="headers头文件"><a href="#headers头文件" class="headerlink" title="headers头文件"></a>headers头文件</h3><ul>
<li>有些网站对爬虫反感，对爬虫请求一律拒绝，这时候我们需要伪装成浏览器，通过修改http中的headers来实现  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">headers = &#123;</div><div class="line">&apos;Host&apos;: &quot;bj.lianjia.com&quot;,</div><div class="line">&apos;Accept&apos;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;,</div><div class="line">&apos;Accept-Encoding&apos;: &quot;gzip, deflate, sdch&quot;,</div><div class="line">&apos;Accept-Language&apos;: &quot;zh-CN,zh;q=0.8&quot;,</div><div class="line">&apos;User-Agent&apos;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.87 Safari/537.36&quot;,</div><div class="line">&apos;Connection&apos;: &quot;keep-alive&quot;,</div><div class="line">&#125;</div><div class="line">p = requests.get(url, headers=headers)</div><div class="line">print(p.content.decode(&apos;utf-8&apos;))</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="模拟登陆"><a href="#模拟登陆" class="headerlink" title="模拟登陆"></a>模拟登陆</h3><ul>
<li>一般登录的过程都伴随有验证码，这里我们通过selenium自己构造post数据进行提交，将返回验证码图片的链接地址输出到控制台下，点击图片链接识别验证码，输入验证码并提交，完成登录。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys    #</div><div class="line">from selenium.webdriver.support.ui import WebDriverWait   # WebDriverWait的作用是等待某个条件的满足之后再往后运行</div><div class="line">from selenium.webdriver import ActionChains</div><div class="line">import time</div><div class="line">import sys</div><div class="line">driver = webdriver.PhantomJS(executable_path=&apos;C:\PyCharm 2016.2.3\phantomjs\phantomjs.exe&apos;)  # 构造网页驱动</div><div class="line"></div><div class="line">driver.get(&apos;https://www.zhihu.com/#signin&apos;)       # 打开网页</div><div class="line">driver.find_element_by_xpath(&apos;//input[@name=&quot;password&quot;]&apos;).send_keys(&apos;your_password&apos;)</div><div class="line">driver.find_element_by_xpath(&apos;//input[@name=&quot;account&quot;]&apos;).send_keys(&apos;your_account&apos;)</div><div class="line">driver.get_screenshot_as_file(&apos;zhihu.jpg&apos;)                   # 截取当前页面的图片</div><div class="line">input_solution = input(&apos;请输入验证码 :&apos;)</div><div class="line">driver.find_element_by_xpath(&apos;//input[@name=&quot;captcha&quot;]&apos;).send_keys(input_solution)</div><div class="line">time.sleep(2)</div><div class="line"></div><div class="line">driver.find_element_by_xpath(&apos;//form[@class=&quot;zu-side-login-box&quot;]&apos;).submit()  # 表单的提交  表单的提交，即可以选择登录按钮然后使用click方法，也可以选择表单然后使用submit方法</div><div class="line">sreach_widonw = driver.current_window_handle     # 用来定位当前页面</div><div class="line"># driver.find_element_by_xpath(&apos;//button[@class=&quot;sign-button submit&quot;]&apos;).click()</div><div class="line">try:</div><div class="line">dr = WebDriverWait(driver,5)</div><div class="line"># dr.until(lambda the_driver: the_driver.find_element_by_xpath(&apos;//a[@class=&quot;zu-side-login-box&quot;]&apos;).is_displayed())</div><div class="line">if driver.find_element_by_xpath(&apos;//*[@id=&quot;zh-top-link-home&quot;]&apos;):</div><div class="line">print(&apos;登录成功&apos;)</div><div class="line">except:</div><div class="line">print(&apos;登录失败&apos;)</div><div class="line">driver.save_screenshot(&apos;screen_shoot.jpg&apos;)     #截取当前页面的图片</div><div class="line">sys.exit(0)</div><div class="line">driver.quit()   #退出驱动</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="代理ip"><a href="#代理ip" class="headerlink" title="代理ip"></a>代理ip</h3><ul>
<li>当爬取速度过快时，当请求次数过多时都面临ip被封的可能。因此使用代理也是必备的。</li>
<li><p>使用request加代理</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import requests</div><div class="line">proxies = &#123; &quot;http&quot;: &quot;http://10.10.1.10:3128&quot;,</div><div class="line">&quot;https&quot;: &quot;http://10.10.1.10:1080&quot;,&#125;</div><div class="line">p = request.get(&quot;http://www.baidu.com&quot;, proxies = proxies)</div><div class="line">print(p.content.decode(&apos;utf-8&apos;))</div></pre></td></tr></table></figure>
</li>
<li><p>使用urllib加代理</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">user_agent =&apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.22 Safari/537.36 SE 2.X MetaSr 1.0&apos;</div><div class="line">headers = &#123;&apos;User-Agent&apos;:user_agent&#125;</div><div class="line">proxy = &#123;&apos;http&apos;:&apos;http://10.10.1.10:1080&apos;,&#125;</div><div class="line">proxy_handler = urllib.request.ProxyHandler(proxy)</div><div class="line">opener = urllib.request.build_opener(proxy_handler)</div><div class="line">urllib.request.install_opener(opener)</div><div class="line">url = &quot;https://www.baidu.com/&quot;</div><div class="line">req = urllib.request.Request(url=url,headers=headers)</div><div class="line">res = urllib.request.urlopen(req)</div><div class="line">print(res.read().decode(&apos;utf-8&apos;))   # 打印网页内容</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="验证码输入"><a href="#验证码输入" class="headerlink" title="验证码输入"></a>验证码输入</h3><ul>
<li>遇到验证的问题，我一般都是人工识别：获取验证码的链接再控制台下 ——&gt; 点击链接识别验证码 ——&gt; 在控制台手动输入验证码并提交。</li>
</ul>
<h3 id="ajax加载的数据-此处博主推荐第一种方式"><a href="#ajax加载的数据-此处博主推荐第一种方式" class="headerlink" title="ajax加载的数据(此处博主推荐第一种方式)"></a>ajax加载的数据(此处博主推荐第一种方式)</h3><ul>
<li><p>对于ajax加载的数据，我们无论通过request或post方法请求得到的网页都无法得到。关于一个网页是否是ajax加载数据，我们只需将网页内容print到控制台下，将其与网页原始内容进行比对，如果有数据缺失，那么这些数据就是ajax加载。例如：我们想获取京东上商品的价格、销量、好评等方面的数据，但是请求返回的网页中没有这些数据。因为这些数据是ajax加载。对于ajax加载的页面，一般有两种方法。</p>
<p>  (1)分析网页 :此处可见我的博客<a href="http://yoghurt-lee.online/2017/02/14/google-network/" target="_blank" rel="external">用google浏览器爬取JS生成的网页时network的使用</a></p>
<p>  (2)使用PhantomJS模拟浏览器行为 :使用PhantomJS模拟浏览器进行发送请求，得到返回的内容是完全的（ajax加载的数据也会有）。但是使用PhantomJS请求速度过慢，一般一个网页4~5s时间，不能忍。一般要使用PhantomJS需要开多线程</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">driver = webdriver.PhantomJS(executable_path=&apos;C:\PyCharm 2016.2.3\phantomjs\phantomjs.exe&apos;)  # 构造网页驱动</div><div class="line">driver.get(&apos;https://www.zhihu.com/&apos;) </div><div class="line">print(driver.page_source)    # 打印网页内容</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h3><p><a href="https://zhuanlan.zhihu.com/p/25174337" target="_blank" rel="external">关于反爬虫的一些总结</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://a1.qpic.cn/psb?/V12rrNui2Gg6Y1/A.1u6LfnKovXteRCYu8iuz3GJ5MSahfm31g9MFHyaYs!/b/dHUAAAAAAAAA&amp;amp;bo=OQSAAgAAAAARAIg!&amp;amp;rf=viewer_4&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="python" scheme="https://yoghurt-lee.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://yoghurt-lee.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>windows下python2.7安装mysqldb</title>
    <link href="https://yoghurt-lee.github.io/2017/02/20/install-mysqldb/"/>
    <id>https://yoghurt-lee.github.io/2017/02/20/install-mysqldb/</id>
    <published>2017-02-20T14:29:10.000Z</published>
    <updated>2017-04-01T23:24:23.157Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i1.piimg.com/584643/865fa19bd8d617aa.jpg" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>前言:有时候运行python爬虫时,需要更为合理的储存,分析大量的数据,这样的话一直借助磁盘文件进行储存和分析是不太方便的,现在我们就来安装MySQLdb。</p>
</blockquote>
<ul>
<li><p>首先,我们需要安装mysql.先去下载mysql的安装包,然后选择<code>custom</code>选择安装目录并安装如下包(我选择的x86版本的).</p>
</li>
<li><p>然后进行mysqldb的安装,可以直接<code>pip install MySQL-Python</code>,但是我出现了如下错误:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error: Microsoft Visual C++ 9.0 is required.</div></pre></td></tr></table></figure>
<p>  缺少VC++,所以我们下载<a href="http://www.microsoft.com/en-us/download/details.aspx?id=44266" target="_blank" rel="external">VCForPython27</a></p>
</li>
<li><p>当我安装完后控制台又出现如下错误</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_mysql.c(42) : fatal error C1083: Cannot open include file: &apos;config-win.h&apos;: No such file or directory  </div><div class="line">   error: command &apos;C:\\Users\\Administrator\\AppData\\Local\\Programs\\Common\\Microsoft\\Visual C++ for Python\\9.0\\VC\\Bin\\cl.exe&apos; failed with exit status 2</div></pre></td></tr></table></figure>
<p>  这是缺少了这个包:<a href="http://dev.mysql.com/downloads/connector/c/6.0.html#downloads" target="_blank" rel="external">mysql connector</a> ,安装此包要注意你的mysql版本,选择32位或者64位的进行安装.</p>
</li>
<li><p>如果的进行安装了,那么我们可以运行如下脚本:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#coding:utf-8</div><div class="line">import MySQLdb</div><div class="line"></div><div class="line">conn= MySQLdb.connect(</div><div class="line">		host=&apos;localhost&apos;,</div><div class="line">		port = 3306, #端口号一般是3306</div><div class="line">		user=&apos;你的mysql用户名&apos;,</div><div class="line">		passwd=&apos;密码&apos;,</div><div class="line">		db =&apos;test&apos;, #先保证这个数据库mysql中已经存在</div><div class="line">		)</div><div class="line">cur = conn.cursor()</div><div class="line"></div><div class="line">#创建数据表</div><div class="line">cur.execute(&quot;create table student(id int ,name varchar(20),class varchar(30),age varchar(10))&quot;)</div><div class="line"></div><div class="line">#插入一条数据</div><div class="line">cur.execute(&quot;insert into student values(&apos;3&apos;,&apos;Hah&apos;,&apos;3 year 2 class&apos;,&apos;9&apos;)&quot;)</div><div class="line"></div><div class="line"></div><div class="line">#修改查询条件的数据</div><div class="line">#cur.execute(&quot;update student set class=&apos;3 year 1 class&apos; where name = &apos;Tom&apos;&quot;)</div><div class="line"></div><div class="line">#删除查询条件的数据</div><div class="line">#cur.execute(&quot;delete from student where age=&apos;9&apos;&quot;)</div><div class="line"></div><div class="line">cur.close()</div><div class="line">conn.commit()</div><div class="line">conn.close()</div></pre></td></tr></table></figure>
<p>  如果不报错误就说明没问题了.</p>
</li>
</ul>
<p>参考博客:<br><a href="http://blog.csdn.net/xxm524/article/details/48754139" target="_blank" rel="external">mysql-python 安装错误</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i1.piimg.com/584643/865fa19bd8d617aa.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="python" scheme="https://yoghurt-lee.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://yoghurt-lee.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>python爬取图片出现(403 Forbidden)的解决方法</title>
    <link href="https://yoghurt-lee.github.io/2017/02/17/solve-403-Forbidden/"/>
    <id>https://yoghurt-lee.github.io/2017/02/17/solve-403-Forbidden/</id>
    <published>2017-02-17T12:51:11.000Z</published>
    <updated>2017-02-17T13:46:02.410Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i1.piimg.com/584643/8882f90cab6b724a.jpg" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>前言:今天做了一个图片爬虫,遇到了一个很奇怪的问题,但是最终找到了解决方法.</p>
</blockquote>
<ul>
<li><p>今天做了个图片爬虫,但是当我从图片链接去下载图片时,总是报出<code>403 Forbidden</code>,而且当我用别的浏览器打开这个图片链接时,也报这个错误.当时感觉玄学了..<br><img src="http://i1.piimg.com/584643/691d2a6d4343702a.png" alt="Markdown"></p>
</li>
<li><p>解决方法:在headers里面需要一个<code>Referer</code>,告诉了服务器我是从这个页面跳转过去的。（这当然不是真的）然后骗过服务器.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">headers = &#123;&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36&apos;,</div><div class="line">              &apos;Referer&apos;:&apos;跳转之前的网页&apos;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>禁爬虫的手段多种多样,但是总是会有破解方法,经常的解决方法是模拟<code>headers</code>,但是我在google的network里并没有找到<code>Referer</code>,网络世界非常神秘,还有很多的秘密可以探索.</p>
</li>
</ul>
<p>参考博客:<br><a href="http://www.cnblogs.com/wasss/p/3990803.html" target="_blank" rel="external">python 3.4 爬虫，伪装浏览器（403 Forbidden）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i1.piimg.com/584643/8882f90cab6b724a.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://yoghurt-lee.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://yoghurt-lee.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="html" scheme="https://yoghurt-lee.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>安装Fiddler</title>
    <link href="https://yoghurt-lee.github.io/2017/02/15/use-Fiddler/"/>
    <id>https://yoghurt-lee.github.io/2017/02/15/use-Fiddler/</id>
    <published>2017-02-15T08:27:24.000Z</published>
    <updated>2017-02-15T09:44:12.809Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i1.piimg.com/584643/a1eb4fba6cdec2a3.jpg" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>前言:有时候我们想要得到手机APP里面的数据,但是电脑怎么能够爬取呢?这里介绍一款强大的工具<code>Fiddler</code>,让电脑能够拦截手机的数据包.</p>
</blockquote>
<h2 id="安装并配置Fiddler"><a href="#安装并配置Fiddler" class="headerlink" title="安装并配置Fiddler"></a>安装并配置Fiddler</h2><ul>
<li><p>在 <a href="https://www.telerik.com/download/fiddler" target="_blank" rel="external">Fiddler下载</a> 下载安装包并安装.</p>
</li>
<li><p>配置Fiddler:点击Tools,选择<code>Telerik Fiddler Options</code>(有的版本就只是<code>Fiddler Options</code>),点击HTTPS,将如下选项勾上,Fiddler就可以截获HTTPS请求。但是这样就会使得连接不安全,后面将解决这个问题.<br><img src="http://i1.piimg.com/584643/36ca8e736cdc3bfd.png" alt="Markdown"></p>
</li>
<li><p>同样的在这里点击Connections,默认端口为8888,将<code>Allow remote computers to connect</code>勾上,表示允许别的机器把HTTP/HTTPS请求发送到Fiddler上来.<br><img src="http://i1.piimg.com/584643/3aa8ec85a6f8c039.png" alt="Markdown"></p>
</li>
</ul>
<h2 id="设置Android手机"><a href="#设置Android手机" class="headerlink" title="设置Android手机"></a>设置Android手机</h2><ul>
<li><p>在电脑的命令行中输入<code>ipconfig</code>,得到IP地址.<br><img src="http://i1.piimg.com/584643/fd7533e8b030cda3.png" alt="Markdown"></p>
</li>
<li><p>长按wifi,点击显示高级选项,代理设置改为手动,代理服务器主机名为电脑IP地址,代理服务器端口为8888,接下来就可以使用Fiddler进行抓包了.<br><img src="http://i1.piimg.com/584643/15c7a2f410595fc4.png" alt="Markdown"></p>
</li>
<li><p>手机和电脑必须要处于同一网络下.</p>
</li>
</ul>
<h2 id="设置安全证书"><a href="#设置安全证书" class="headerlink" title="设置安全证书"></a>设置安全证书</h2><ul>
<li><p>前面说过,如果不设置安全证书手机电脑访问<code>https</code>的网站都会显示此连接并不安全.</p>
</li>
<li><p>首先,设置手机的安全证书.手机进入<code>http://你的电脑IP地址:8888</code>,点击最下面的<code>FiddlerRoot certificate</code>下载Fiddler的安全证书.</p>
</li>
<li><p>firefox设置电脑的安装证书.点击点击下图Action按钮,点击<code>Export Root Certificate to Desktop</code>下载安全证书到桌面.<br><img src="http://i1.piimg.com/584643/1395c38e631fb09f.png" alt="Markdown"></p>
</li>
<li><p>在火狐浏览器按照如图所示导入安全证书即可.<br><img src="http://i1.piimg.com/584643/90341e7cfdb639ea.png" alt="Markdown"><br><img src="http://i1.piimg.com/584643/ed72658d8177369d.png" alt="Markdown"></p>
</li>
</ul>
<p>参考博客:<br><a href="https://my.oschina.net/jhao104/blog/605963" target="_blank" rel="external">Fiddler抓取手机APP数据包</a><br><a href="http://www.tuicool.com/articles/fAfmMjA" target="_blank" rel="external">Fiddler下Firefox提示“您的连接并不安全”的解决办法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i1.piimg.com/584643/a1eb4fba6cdec2a3.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="html" scheme="https://yoghurt-lee.github.io/tags/html/"/>
    
      <category term="Fiddler" scheme="https://yoghurt-lee.github.io/tags/Fiddler/"/>
    
  </entry>
  
  <entry>
    <title>用google浏览器爬取JS生成的网页时network的使用</title>
    <link href="https://yoghurt-lee.github.io/2017/02/14/google-network/"/>
    <id>https://yoghurt-lee.github.io/2017/02/14/google-network/</id>
    <published>2017-02-14T08:02:20.000Z</published>
    <updated>2017-04-01T23:27:22.104Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i2.muimg.com/584643/e8421d12a7070b80.jpg" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>前言:最近使用python写了个爬虫,爬取动态网页上的数据,google自带的network帮了我很多忙,记录一下使用的时候的收获.这篇博客将随着我对network的不断加深认识而更新.</p>
</blockquote>
<h2 id="如何使用network"><a href="#如何使用network" class="headerlink" title="如何使用network"></a>如何使用network</h2><ul>
<li><p>在某网站,比如我自己的页面,按<code>F12</code>,出现如下界面,找到其中的network,然后按<code>F5</code>刷新.然后会获得传输的所有数据包.<br><img src="http://i1.piimg.com/584643/43e51ba5a643d1f9.png" alt="Markdown"></p>
</li>
<li><p>network下面有一个<code>Preserve log</code>,之前默认是没有点击的.如果打上勾,当你从上一个网页跳转到下一个网站时,本来上一个网页的数据会被清空,如果打上勾,那么前面的过程也会被记录,这个很重要,比如当你登录到某网站时打上勾就可以看到登录页面传送的信息.<br><img src="http://i1.piimg.com/584643/9e6e403043d2399a.png" alt="Markdown"></p>
</li>
<li><p>下图所显示的也就是我们所抓到的包了,所有的包都在ALL里面,但是在ALL里面的包太多了,一个个查看太费时间.常用的包有两个<code>XHR</code>和<code>Doc</code>里面,<code>XHR</code>里面携带的数据包内容一般是json数据;<code>Doc</code>里面携带的数据包内容一般是html。一般可以在这两个里面找到页面生成的数据.<br><img src="http://p1.bqimg.com/584643/918ce79716a01590.png" alt="Markdown"></p>
</li>
<li><p>以上是network的基本应用,下面说如何查看包中数据.</p>
</li>
</ul>
<h2 id="network中数据包怎么看"><a href="#network中数据包怎么看" class="headerlink" title="network中数据包怎么看."></a>network中数据包怎么看.</h2><ul>
<li><p>静态网页中的数据一般很容易找到,但是如果是js生成的数据,那么在网页的源代码中是无法看到的,比如说这个网站,我们需要这个表格的信息(图一).但是我们在源代码中只能看到如下信息(图二).<br><img src="http://p1.bqimg.com/584643/e1cd1cbf3635e5fa.png" alt="Markdown"> (图一)<br><img src="http://p1.bqimg.com/584643/f3d4de75f5ebc2a5.png" alt="Markdown"> (图二)</p>
</li>
<li><p>解决方法只有两种,模拟这个网页的js代码生成数据,这不太现实;另一种就是分析包数据包,找到需要的信息.方法如下,在下面的数据包的信息里面点击<code>Preview</code>,就可以看到该数据包所携带的信息,一般JS生成的数据都是以json数据(类似于python的dict)的形式储存在里面.<br><img src="http://p1.bqimg.com/584643/06c179c0479f2fc4.png" alt="Markdown"></p>
</li>
<li><p>OK,找到了数据,接下来就是怎么获得这些数据了.接下来点击该数据包的<code>Headers</code>,看如下信息:我们发现了该数据源的url,发现了该网页是以post方法进行访问的.既然是post,那么下面应该会有数据,我们接着往下看.<br><img src="http://p1.bqimg.com/584643/34ba9b969dcd3ea0.png" alt="Markdown"></p>
</li>
<li><p>翻到了下面,果然访问该数据源是要携带数据的,我们只要利用这些数据,就可以顺利获得该数据源的信息了.<br><img src="http://p1.bqimg.com/584643/d4cd95feb84559c9.png" alt="Markdown"></p>
</li>
<li><p>还有一个值得注意的地方就是我们一般都需要伪装成一个正常的浏览器,所以需要设置用户代理(<code>User-agent</code>),另外如果网页有<code>cookie</code>的话,我们需要将它存下了,下面我的python代码将实现这些功能。当然,如果对一些防爬虫比较严格的网页,可能就需要完全模拟Headers了.<br><img src="http://p1.bqimg.com/584643/3dae9e79fa6e8ce9.png" alt="Markdown">    </p>
</li>
</ul>
<h2 id="以下是python实现爬取这些数据的一般模板代码"><a href="#以下是python实现爬取这些数据的一般模板代码" class="headerlink" title="以下是python实现爬取这些数据的一般模板代码."></a>以下是python实现爬取这些数据的一般模板代码.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import cookielib</div><div class="line">import json</div><div class="line">import urllib2</div><div class="line">import urllib</div><div class="line">#获得一个cookieJar实例</div><div class="line">cj = cookielib.CookieJar()</div><div class="line">#cookieJar作为参数，获得一个opener的实例</div><div class="line">opener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))</div><div class="line">#伪装成一个正常的浏览器，避免有些web服务器拒绝访问。</div><div class="line">opener.addheaders = [(&apos;User-agent&apos;,&apos;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&apos;)]</div><div class="line">#需要访问数据源Headers中的的url</div><div class="line">url = &quot;XXXXXXXXX&quot;</div><div class="line">#最下面需要提交的数据,以键值对进行储存</div><div class="line">submit_data = urllib.urlencode(&#123;&quot;xxx&quot;:&quot;XXX&quot;,&quot;yyy&quot;:&quot;YYY&quot;&#125;)</div><div class="line">#以post的方法访问登陆页面，访问之后cookieJar会自动保存cookie</div><div class="line">op = opener.open(url,submit_data)</div><div class="line">#读取获得的数据源</div><div class="line">data = op.read()</div><div class="line">#解析成json数据,接下来就可以直接以键值对的方式访问数据源了</div><div class="line">data = json.loads(data)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i2.muimg.com/584643/e8421d12a7070b80.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="python" scheme="https://yoghurt-lee.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://yoghurt-lee.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="html" scheme="https://yoghurt-lee.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>python获取百度搜索结果的真实URL</title>
    <link href="https://yoghurt-lee.github.io/2017/02/12/python_spider_baidu/"/>
    <id>https://yoghurt-lee.github.io/2017/02/12/python_spider_baidu/</id>
    <published>2017-02-12T12:36:10.000Z</published>
    <updated>2017-02-12T13:58:40.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p1.bqimg.com/584643/305bb7549ba47162.jpg" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>最近将以前的爬虫代码(针对杭州电子科技大学在线测评系统)拿出来进行测试,发现百度对所有的外链都进行了加密?以前一直没注意过这种问题,然后我尝试了很多方法。</p>
</blockquote>
<h4 id="首先-破解百度加密算法是不可能的-我自己尝试了先将外链取出来"><a href="#首先-破解百度加密算法是不可能的-我自己尝试了先将外链取出来" class="headerlink" title="首先,破解百度加密算法是不可能的,我自己尝试了先将外链取出来:"></a>首先,破解百度加密算法是不可能的,我自己尝试了先将外链取出来:</h4><ul>
<li><p>首先我用如下代码将我需要的外链全部弄了出来</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">html = str(D(url)) #此处为下载百度搜索界面</div><div class="line">   soup = BeautifulSoup(html) #通过BeautifulSoup来做匹配</div><div class="line">   list_soup = soup.find(&apos;div&apos;,&#123;&apos;id&apos;:&apos;content_left&apos;&#125;)</div><div class="line">   links = [link.get(&apos;href&apos;) for link in list_soup.findAll(&apos;a&apos;,&#123;&apos;class&apos;:&apos;c-showurl&apos;&#125;)]</div></pre></td></tr></table></figure>
</li>
<li><p>然后我尝试了先对该链接发送一个request,然后获得response,通过response获得原url。我还沾沾自喜,然后发现效率奇慢.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def real_links(links):</div><div class="line">   reallinks = []</div><div class="line">   url = &quot;http://www.baidu.com/link&quot;</div><div class="line">   regex = re.compile(url)</div><div class="line">   links = [link for link in links if re.match(regex, link)]</div><div class="line">   for link in links:</div><div class="line">       try:</div><div class="line">           bbase = BrowserBase() #此类乃我封装的一个获得response的类</div><div class="line">           response = bbase.openurl(link)</div><div class="line">           reallinks.append(response.geturl())</div><div class="line">       except Exception as e:</div><div class="line">           print str(e)</div><div class="line">   return reallinks</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="解决办法还是在网上找-发现有人早已发现怎么解决这个问题-原来跳转网页的head里面包含了一条location里面就已经包含了原网址"><a href="#解决办法还是在网上找-发现有人早已发现怎么解决这个问题-原来跳转网页的head里面包含了一条location里面就已经包含了原网址" class="headerlink" title="解决办法还是在网上找,发现有人早已发现怎么解决这个问题,原来跳转网页的head里面包含了一条location里面就已经包含了原网址!"></a>解决办法还是在网上找,发现有人早已发现怎么解决这个问题,原来跳转网页的head里面包含了一条<code>location</code>里面就已经包含了原网址!</h4><ul>
<li><p>python代码如下:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def get_real_links(links):</div><div class="line">   real_links = []</div><div class="line">   import requests</div><div class="line">   for link in links:</div><div class="line">       retry = 2</div><div class="line">       while(retry&gt;0):</div><div class="line">           try:</div><div class="line">               header = requests.head(link).headers</div><div class="line">               real_links.append(header[&apos;location&apos;])</div><div class="line">               break</div><div class="line">           except Exception as e:</div><div class="line">               print str(e)</div><div class="line">               retry-=1</div><div class="line">               continue</div><div class="line">   return real_links</div></pre></td></tr></table></figure>
</li>
<li><p>参考自 <a href="http://www.itseo.net/direction/show-156.html" target="_blank" rel="external">如何“破解”百度搜索结果中的加密地址</a></p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>网上牛人多,遇到问题不要钻牛角尖,别人已经造好了轮子.</li>
<li>独立思考没错,但是一定要谦逊.</li>
<li>道高一尺,魔高一丈.</li>
<li><a href="https://github.com/yoghurt-lee/python_hdu_spider" target="_blank" rel="external">hdu爬虫</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p1.bqimg.com/584643/305bb7549ba47162.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="python" scheme="https://yoghurt-lee.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://yoghurt-lee.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>使用py2exe将python项目变成可执行exe文件</title>
    <link href="https://yoghurt-lee.github.io/2017/02/04/how-to-use-py2exe/"/>
    <id>https://yoghurt-lee.github.io/2017/02/04/how-to-use-py2exe/</id>
    <published>2017-02-04T03:24:20.000Z</published>
    <updated>2017-02-19T08:59:33.048Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i1.piimg.com/584643/478e3a7ffeb1cede.jpg" alt="Markdown"><br><a id="more"></a></p>
<blockquote>
<p>python是很方便进行开发的语言,但是,许多人的电脑里面并没有安装python,我们可以用py2exe将python项目生成exe文件.</p>
</blockquote>
<h2 id="Windows安装py2exe"><a href="#Windows安装py2exe" class="headerlink" title="Windows安装py2exe"></a>Windows安装py2exe</h2><ul>
<li>去官网下载并找到合适的py2exe版本: <a href="https://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/" target="_blank" rel="external">官方下载地址</a></li>
<li>直接点击.exe文件就ok</li>
<li>另一种方式就是用pip命令进行安装</li>
</ul>
<h2 id="在项目文件下建立setup-py"><a href="#在项目文件下建立setup-py" class="headerlink" title="在项目文件下建立setup.py"></a>在项目文件下建立setup.py</h2><ul>
<li>内容如下,将main.py改为你的项目下的主项目名即可.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#coding:utf-8</div><div class="line">from distutils.core import setup</div><div class="line">import py2exe</div><div class="line"></div><div class="line">setup(console=[&quot;main.py&quot;]) #console=&quot;主项目名.py&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="生成exe文件"><a href="#生成exe文件" class="headerlink" title="生成exe文件"></a>生成exe文件</h2><ul>
<li>cmd命令运行控制台,切换到项目文件下,运行如下命令:<br><code>python setup.py py2exe</code></li>
<li>如果你的项目中有第三方库,那么生成的exe文件有可能会出现闪退现象。那么我们需要运行如下命令将第三方库和exe文件链接起来:<br><code>python setup.py py2exe -p 第三方库的名字</code><br>比如我的项目文件下存在lxml,gzip这种第三方库,那么就运行:<br><code>python setup.py py2exe -p lxml,gzip</code></li>
<li>在项目文件下会生成两个文件夹bulid和dist,在dist文件下点击main.exe文件即可运行.</li>
</ul>
<h2 id="生成的exe文件出现的中文乱码问题"><a href="#生成的exe文件出现的中文乱码问题" class="headerlink" title="生成的exe文件出现的中文乱码问题"></a>生成的exe文件出现的中文乱码问题</h2><ul>
<li>我的程序中有输入(input,raw_input),一直是乱码,然后我将中文字符串str前面加上了u’str’,但是exe文件又出现了闪退现象,然后最后的解决方法是:<br><code>str.decode(&#39;utf-8&#39;).encode(&#39;gb2312&#39;)</code><br>输出(print)的话前面加上u即可正常显示,暂时没发现问题.  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i1.piimg.com/584643/478e3a7ffeb1cede.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="python" scheme="https://yoghurt-lee.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>将本地项目上传到github</title>
    <link href="https://yoghurt-lee.github.io/2017/01/27/blog2/"/>
    <id>https://yoghurt-lee.github.io/2017/01/27/blog2/</id>
    <published>2017-01-27T14:22:19.000Z</published>
    <updated>2017-09-14T07:57:02.426Z</updated>
    
    <content type="html"><![CDATA[<p><img src="\img\blog2_1.jpg" alt="Alt text"></p>
<blockquote>
<p>以下为我的第一次上传代码到github,记录一个</p>
</blockquote>
<a id="more"></a>
<ul>
<li><p>首先:在需要上传的文件目录运行如下命令,创建 git 仓库<br>  <code>git init</code></p>
</li>
<li><p>第二步:将本地所有文件添加到仓库(如果不全部添加则将 . 改成文件名)<br>  <code>git add .</code></p>
</li>
<li><p>第三步:将add的文件commit到仓库<br>  <code>git commit -m &quot;注释&quot;</code></p>
</li>
<li><p>第四步:将在github创建好的代码仓库的 ssh 地址复制,接着运行以下命令<br><img src="\img\blog2_2.jpg" alt="Alt text"></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@github.com:yoghurt-lee/python-crawler-hdu_crawler.git</div></pre></td></tr></table></figure>
</li>
<li><p>第五步:执行pull命令<br>  <code>git pull origin master</code></p>
<p>  在这里我遇到了如下问题<br>  <code>fatal: refusing to merge unrelated histories</code></p>
<p>  那么我们执行如下命令<br>  <code>git pull origin master --allow-unrelated-histories</code></p>
</li>
<li><p>第六步:push到github服务器<br>  <code>git push origin master</code></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;\img\blog2_1.jpg&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下为我的第一次上传代码到github,记录一个&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="github" scheme="https://yoghurt-lee.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>一台电脑管理多个代码仓库出现的问题</title>
    <link href="https://yoghurt-lee.github.io/2017/01/20/blog1/"/>
    <id>https://yoghurt-lee.github.io/2017/01/20/blog1/</id>
    <published>2017-01-20T06:53:53.000Z</published>
    <updated>2017-09-14T07:52:49.740Z</updated>
    
    <content type="html"><![CDATA[<p><img src="\img\blog1_1.jpg" alt="Alt text"><br><a id="more"></a><br>千辛万苦,利用 Github+Hexo 做出了自己的页面,还是有点成就感的,由于是先给别人做了一个之后才做自己的主页,然后我的电脑一些错误,我选其中我被坑得最惨的一个来说说.<br>我被坑得最惨的一个错误是当我执行:<br>    <code>hexo g -d</code><br>电脑总是会报出<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">remote: Permission to XXX denied to XXX.fatal: unable to access &apos;XXX&apos;: The requested URL </div><div class="line">returned error: 403</div></pre></td></tr></table></figure></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><p>使用ssh方式链接到github,我们需要一对私钥/公钥,那么管理不同账号的代码仓库,我们就需要多对私钥/公钥了.</p>
<ul>
<li><p>首先,为每一个账号生成公钥</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_1 -C &quot;xxx@xxx.com&quot;</div><div class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_2 -C &quot;xxx@xxx.com&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>生成好后在<code>.ssh</code>文件夹下新建<code>config</code>文件并编辑，另不同<code>Host</code>实际映射到同一<br><code>HostName</code>,但密钥文件不同.<code>Host</code>前缀可自定义，例子中<code>ieit</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># default                                                                       </div><div class="line">Host github.com</div><div class="line">HostName github.com</div><div class="line">User git</div><div class="line">IdentityFile ~/.ssh/id_rsa_1</div><div class="line"># two                                                                           </div><div class="line">Host ieit.github.com</div><div class="line">HostName github.com</div><div class="line">User git</div><div class="line">IdentityFile ~/.ssh/id_rsa_2</div></pre></td></tr></table></figure>
</li>
<li><p>将生成的<code>id_rsa_1.pub</code>,<code>id_rsa_2.pub</code>内容<code>copy</code>到对应的<code>repo</code></p>
</li>
<li><p>然后通过以下方式验证是否成功</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh -T git@ieit.github.com</div><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure>
<p>  以上参考自:<a href="http://www.jianshu.com/p/3fc93c16ad2d" target="_blank" rel="external">@一台电脑绑定两个github帐号教程</a></p>
</li>
<li><p>到这步为止,网上都有,但是我电脑还是报相同的错误,折腾了我一上午,然后我尝试了很多方法,最后成功了.最后我修改了项目文件下<code>_config.yml</code>中的</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">	type: git</div><div class="line">	repo: https://github.com/yoghurt-lee/yoghurt-lee.github.io.git</div><div class="line">	branch: master</div></pre></td></tr></table></figure>
<p>  修改为</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">	type: git</div><div class="line">	repo: git@github.com:yoghurt-lee/yoghurt-lee.github.io.git</div><div class="line">	branch: master</div></pre></td></tr></table></figure>
<p>  然后就<code>deploy</code>上去了.</p>
<h3 id="如果本教程对你有用-不妨留个脚步"><a href="#如果本教程对你有用-不妨留个脚步" class="headerlink" title="如果本教程对你有用,不妨留个脚步."></a>如果本教程对你有用,不妨留个脚步.</h3></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;\img\blog1_1.jpg&quot; alt=&quot;Alt text&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="https://yoghurt-lee.github.io/tags/Hexo/"/>
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>新的博客,新的开始</title>
    <link href="https://yoghurt-lee.github.io/2017/01/20/post/"/>
    <id>https://yoghurt-lee.github.io/2017/01/20/post/</id>
    <published>2017-01-20T01:42:41.000Z</published>
    <updated>2017-02-15T02:00:26.241Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p1.bqimg.com/584643/38110835cccc2991.jpg" alt="Markdown"><br>从博客园搬出来了,又是一段新的开始,以后常驻此地.<br><a href="http://www.cnblogs.com/liyinggang" target="_blank" rel="external">博客园地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p1.bqimg.com/584643/38110835cccc2991.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;br&gt;从博客园搬出来了,又是一段新的开始,以后常驻此地.&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.co
    
    </summary>
    
    
      <category term="博客" scheme="https://yoghurt-lee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="文章" scheme="https://yoghurt-lee.github.io/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
</feed>
